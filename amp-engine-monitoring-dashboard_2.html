<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMP 모니터링 대시보드</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    
    <!-- 실제 최고값 표시 플러그인 -->
    <script>
        // Chart.js 로드 확인
        console.log('Chart.js 로드됨:', typeof Chart !== 'undefined');
        
        // Chart.js annotation 플러그인 등록
        if (typeof ChartAnnotation !== 'undefined') {
            Chart.register(ChartAnnotation);
            console.log('Chart.js annotation 플러그인 등록됨');
        } else {
            console.log('Chart.js annotation 플러그인을 찾을 수 없음');
        }
        
        Chart.register({
            id: 'maxValueDisplay',
            afterDraw: function(chart) {
                const ctx = chart.ctx;
                const options = chart.options.plugins.maxValueDisplay;
                
                if (!options || !options.display) return;
                
                // 실제 데이터에서 최고값 찾기
                let maxValue = 0;
                let maxIndex = 0;
                let maxDatasetIndex = 0;
                
                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    if (dataset.data && Array.isArray(dataset.data)) {
                        dataset.data.forEach((value, index) => {
                            if (typeof value === 'number' && value > maxValue) {
                                maxValue = value;
                                maxIndex = index;
                                maxDatasetIndex = datasetIndex;
                            }
                        });
                    }
                });
                
                if (maxValue === 0) return;
                
                const color = options.color || '#ef4444';
                const fontSize = options.fontSize || 12;
                const fontWeight = options.fontWeight || 'bold';
                
                // X축과 Y축 스케일에서 최고값의 픽셀 위치 계산
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;
                const xPixel = xScale.getPixelForValue(chart.data.labels[maxIndex]);
                const yPixel = yScale.getPixelForValue(maxValue);
                
                // 차트 영역 내부인지 확인
                if (xPixel >= xScale.left && xPixel <= xScale.right && 
                    yPixel >= yScale.top && yPixel <= yScale.bottom) {
                    
                    // 최고값 포인트에 원 그리기
                    ctx.save();
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(xPixel, yPixel, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // 흰색 테두리
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                    
                    // MAX 값 텍스트 그리기 (포인트 위쪽에)
                    ctx.save();
                    ctx.fillStyle = color;
                    ctx.font = `${fontWeight} ${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    
                    // 차트 설정에서 단위 가져오기
                    const unit = getChartUnit(chart.options.plugins.maxValueDisplay.chartConfig || {});
                    
                    // 텍스트 배경
                    const text = `MAX ${maxValue.toFixed(1)}${unit}`;
                    const textMetrics = ctx.measureText(text);
                    const textWidth = textMetrics.width;
                    const textHeight = fontSize;
                    const padding = 6;
                    
                    // 배경 사각형 그리기
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.fillRect(
                        xPixel - textWidth / 2 - padding,
                        yPixel - textHeight - padding * 2,
                        textWidth + padding * 2,
                        textHeight + padding * 2
                    );
                    
                    // 텍스트 그리기
                    ctx.fillStyle = color;
                    ctx.fillText(text, xPixel, yPixel - padding);
                    ctx.restore();
                }
            }
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-blue: #3b82f6;
            --primary-purple: #4b5563;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #f1f5f9;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-muted: #6c757d;
            --border-color: #e9ecef;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            
            /* 엔진별 색상 */
            --stt-primary: #10b981;  /* 초록색 */
            --tts-primary: #3b82f6;  /* 파란색 */
            --sv-primary: #8b5cf6;   /* 보라색 */
            --hw-primary: #6b7280;
            
            /* 상태별 색상 */
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --info: #06b6d4;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* 헤더 */
        .header {
            background: linear-gradient(135deg, var(--primary-blue), var(--primary-purple));
            color: white;
            padding: 0.75rem 1.5rem;
            box-shadow: var(--shadow-md);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            align-items: center;
            max-width: 1600px;
            margin: 0 auto;
            gap: 2rem;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-title h1 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .header-info {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            font-size: 0.8rem;
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            margin-left: auto;
        }

        .time-display i {
            font-size: 0.8rem;
        }

        .time-display span {
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
        }

        /* 조회 기능 패널 */
        .query-panel {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.3rem 0.6rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-height: 36px;
            flex-wrap: nowrap;
            gap: 0.3rem;
        }

        .realtime-mode {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .query-mode {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .query-btn {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.2rem 0.4rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .query-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .query-btn.stop-btn {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .query-btn.start-btn {
            background: rgba(16, 185, 129, 0.2);
            border-color: rgba(16, 185, 129, 0.5);
        }

        .realtime-status {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
        }

        .status-indicator {
            position: relative;
            width: 8px;
            height: 8px;
        }

        .pulse-circle {
            width: 8px;
            height: 8px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .refresh-interval {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 0.15rem 0.3rem;
            border-radius: 3px;
            font-size: 0.55rem;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.3);
            min-width: 80px;
        }

        .datetime-inputs {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .datetime-input {
            width: 80px;
            font-size: 0.55rem;
            padding: 0.15rem 0.25rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .datetime-input::-webkit-calendar-picker-indicator {
            filter: invert(1);
        }

        .range-separator {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.6rem;
        }

        .duration-badge {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 0.15rem 0.3rem;
            border-radius: 3px;
            font-size: 0.55rem;
            white-space: nowrap;
            min-width: 90px;
        }

        .duration-badge:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .duration-badge:focus {
            outline: none;
            border-color: #3b82f6;
            background: white;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .duration-badge option {
            background: white;
            color: #1f2937;
            padding: 0.5rem;
        }

        .interval-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.55rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .interval-select {
            width: 50px;
            font-size: 0.55rem;
            padding: 0.15rem 0.3rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .interval-select option {
            background: #1f2937;
            color: white;
        }

        /* 조회 기능 패널 */
        .query-panel {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.3rem 0.6rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-height: 36px;
            flex-wrap: nowrap;
            gap: 0.3rem;
        }

        .realtime-mode {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .query-mode {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .query-btn {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.2rem 0.4rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .query-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .query-btn.stop-btn {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .query-btn.start-btn {
            background: rgba(16, 185, 129, 0.2);
            border-color: rgba(16, 185, 129, 0.5);
        }

        .realtime-status {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
        }

        .status-indicator {
            position: relative;
            width: 8px;
            height: 8px;
        }

        .pulse-circle {
            width: 8px;
            height: 8px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .refresh-interval {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 0.15rem 0.3rem;
            border-radius: 3px;
            font-size: 0.55rem;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.3);
            min-width: 80px;
        }

        .datetime-inputs {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .datetime-input {
            width: 80px;
            font-size: 0.55rem;
            padding: 0.15rem 0.25rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .datetime-input::-webkit-calendar-picker-indicator {
            filter: invert(1);
        }

        .range-separator {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.6rem;
        }

        .duration-badge {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 0.15rem 0.3rem;
            border-radius: 3px;
            font-size: 0.55rem;
            white-space: nowrap;
            min-width: 90px;
        }

        .duration-badge:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .duration-badge:focus {
            outline: none;
            border-color: #3b82f6;
            background: white;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .duration-badge option {
            background: white;
            color: #1f2937;
            padding: 0.5rem;
        }

        .interval-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.55rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .interval-select {
            width: 50px;
            font-size: 0.55rem;
            padding: 0.15rem 0.3rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .interval-select option {
            background: #1f2937;
            color: white;
        }

        /* 대시보드 선택 패널 */
        .dashboard-selection-panel {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-left: auto;
            margin-right: 1rem;
        }

        .selection-group {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .selection-divider {
            width: 1px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            margin: 0 1rem;
            align-self: center;
        }

        .selection-label {
            font-size: 0.7rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
        }

        .mode-buttons {
            display: flex;
            gap: 0.3rem;
        }

        .mode-btn {
            padding: 0.3rem 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: rgba(255, 255, 255, 0.5);
        }

        .dashboard-type-buttons {
            display: flex;
            gap: 0.3rem;
        }

        .type-btn {
            padding: 0.3rem 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .type-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .type-btn.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: rgba(255, 255, 255, 0.5);
        }

        .dashboard-dropdown {
            padding: 0.3rem 0.6rem;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.9);
            color: #1f2937;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            cursor: pointer;
            min-width: 120px;
            transition: all 0.2s ease;
        }

        .dashboard-dropdown:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .dashboard-dropdown:focus {
            outline: none;
            border-color: #3b82f6;
            background: white;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .dashboard-dropdown option {
            background: white;
            color: #1f2937;
            padding: 0.5rem;
        }

        /* 서버 선택 패널 */
        .server-selection-panel {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            display: block;
        }

        .server-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
        }

        .server-panel-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .server-panel-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .server-action-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            white-space: nowrap;
            writing-mode: horizontal-tb;
        }

        .server-action-btn:hover {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }

        .server-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.75rem;
        }

        .mode-toggle {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 2px;
            gap: 2px;
        }

        .mode-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.8rem;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* 컨트롤 패널 */


        /* 대시보드 선택 */
        .dashboard-selector {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .dashboard-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            position: relative;
        }

        .dashboard-btn:hover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .dashboard-btn.active {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }

        .dashboard-btn.admin {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .dashboard-btn.admin:hover {
            border-color: #d97706;
            background: rgba(245, 158, 11, 0.2);
        }

        .dashboard-btn.admin.active {
            background: #f59e0b;
            color: white;
            border-color: #f59e0b;
        }

        .dashboard-btn.personal {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        .dashboard-btn.personal:hover {
            border-color: #059669;
            background: rgba(16, 185, 129, 0.2);
        }

        .dashboard-btn.personal.active {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        /* 대시보드 타입 표시 */
        .dashboard-btn::after {
            content: '';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: transparent;
        }

        .dashboard-btn.admin::after {
            background: #f59e0b;
        }

        .dashboard-btn.personal::after {
            background: #10b981;
        }

        /* 글로벌 설정 */
        .global-settings {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.75rem;
        }

        .time-select, .threshold-input {
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: white;
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        /* 메인 컨테이너 */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* 카드 표시 옵션 패널 */
        .card-options-panel {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            display: none;
        }

        .edit-mode .card-options-panel {
            display: block;
        }

        .options-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .options-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .edit-mode-actions {
            display: flex;
            gap: 0.5rem;
        }

        .edit-action-btn {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .edit-action-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .edit-action-btn.secondary:hover {
            background: var(--border-color);
            color: var(--text-primary);
        }

        .edit-action-btn.primary {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }

        .edit-action-btn.primary:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        .options-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: flex-start;
            padding: 0.2rem 0;
        }

        .option-group {
            display: flex;
            flex-direction: row;
            gap: 0.3rem;
            align-items: center;
            flex-wrap: wrap;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 0.3rem 0.5rem;
            margin-bottom: 0.5rem;
            width: 100%;
        }

        .option-label {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-right: 0.5rem;
            white-space: nowrap;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-label:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: scale(1.05);
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            align-items: center;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.1rem 0.2rem;
            border-radius: 3px;
            transition: background-color 0.2s;
            flex-shrink: 0;
        }

        .checkbox-item:hover {
            background: rgba(59, 130, 246, 0.05);
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
            scale: 0.8;
        }

        .checkbox-item label {
            font-size: 0.65rem;
            cursor: pointer;
            white-space: nowrap;
        }

        /* 엔진별 그룹 색상 */
        .option-group.common {
            background: #f0f9ff;
            border-color: #0ea5e9;
        }

        .option-group.common .option-label {
            background: rgba(14, 165, 233, 0.1);
            border-color: rgba(14, 165, 233, 0.3);
            color: #0369a1;
        }

        .option-group.common .option-label:hover {
            background: rgba(14, 165, 233, 0.2);
        }

        .option-group.stt {
            background: #dcfce7;
            border-color: #10b981;
        }

        .option-group.stt .option-label {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
            color: #047857;
        }

        .option-group.stt .option-label:hover {
            background: rgba(16, 185, 129, 0.2);
        }

        .option-group.tts {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .option-group.tts .option-label {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #1d4ed8;
        }

        .option-group.tts .option-label:hover {
            background: rgba(59, 130, 246, 0.2);
        }

        .option-group.sv {
            background: #f3e8ff;
            border-color: #8b5cf6;
        }

        .option-group.sv .option-label {
            background: rgba(139, 92, 246, 0.1);
            border-color: rgba(139, 92, 246, 0.3);
            color: #6d28d9;
        }

        .option-group.sv .option-label:hover {
            background: rgba(139, 92, 246, 0.2);
        }

        /* 차트 그리드 */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1rem;
        }

        /* 수정 모드에서 더 유연한 그리드 */
        .edit-mode .charts-grid {
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            position: relative;
        }

        /* 차트 카드 */
        .chart-card {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            position: relative;
            transition: all 0.3s ease;
            min-height: 350px;
            display: flex;
            flex-direction: column;
        }

        .chart-card.stt {
            border-left: 4px solid var(--stt-primary);
        }

        .chart-card.tts {
            border-left: 4px solid var(--tts-primary);
        }

        .chart-card.sv {
            border-left: 4px solid var(--sv-primary);
        }

        .chart-card:hover {
            box-shadow: var(--shadow-md);
            border: 2px solid #3b82f6;
            transform: translateY(-2px);
            transition: all 0.2s ease;
        }

        .chart-card:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: var(--shadow-sm);
            border: 2px solid #1d4ed8;
            background: rgba(59, 130, 246, 0.05);
        }

        .chart-card.selected {
            border: 2px solid #1d4ed8;
            background: rgba(59, 130, 246, 0.1);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }

        .edit-mode .chart-card {
            border: 1px dashed var(--primary-blue);
            cursor: move;
        }

        .edit-mode .chart-card:hover {
            border: 3px solid #2563eb;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
        }

        .edit-mode .chart-card.dragging {
            opacity: 0.9;
            transform: rotate(2deg) scale(1.05);
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            width: auto !important;
            height: auto !important;
            min-width: 280px;
            min-height: 200px;
            max-width: 800px;
            max-height: 600px;
        }


        /* 리사이즈 핸들 */
        .resize-handles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .resize-handle {
            position: absolute;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            pointer-events: all;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s ease;
            z-index: 1001;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .edit-mode .chart-card:hover .resize-handle {
            opacity: 1;
        }

        .edit-mode .resize-handle {
            opacity: 0.8;
        }

        .edit-mode .chart-card.selected .resize-handle {
            opacity: 1;
            background: #1d4ed8;
        }

        .resize-handle:hover {
            background: #2563eb;
            transform: scale(1.3);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .resize-handle.resize-nw {
            top: -7px;
            left: -7px;
            cursor: nw-resize;
        }

        .resize-handle.resize-ne {
            top: -7px;
            right: -7px;
            cursor: ne-resize;
        }

        .resize-handle.resize-sw {
            bottom: -7px;
            left: -7px;
            cursor: sw-resize;
        }

        .resize-handle.resize-se {
            bottom: -7px;
            right: -7px;
            cursor: se-resize;
        }

        .resize-handle.resize-n {
            top: -7px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        .resize-handle.resize-s {
            bottom: -7px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .resize-handle.resize-w {
            top: 50%;
            left: -7px;
            transform: translateY(-50%);
            cursor: w-resize;
        }

        .resize-handle.resize-e {
            top: 50%;
            right: -7px;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .edit-mode .chart-card {
            position: relative;
            min-width: 280px;
            min-height: 200px;
            max-width: 800px;
            max-height: 600px;
            resize: none; /* 기본 리사이즈 비활성화 */
        }

        /* 차트 헤더 */
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            min-height: 50px;
        }

        .chart-title-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            min-width: 0;
        }

        .chart-header-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        /* 새로운 차트 액션 버튼 스타일 */
        .chart-action-btn {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 0.5rem;
            cursor: pointer;
            color: #64748b;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            font-size: 0.875rem;
        }

        .chart-action-btn:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
            color: #475569;
            transform: translateY(-1px);
        }

        .period-query-btn {
            background: #10b981;
            border-color: #059669;
            color: white;
        }

        .period-query-btn:hover {
            background: #059669;
            border-color: #047857;
            color: white;
        }

        .chart-settings-btn {
            background: #3b82f6;
            border-color: #2563eb;
            color: white;
        }

        .chart-settings-btn:hover {
            background: #2563eb;
            border-color: #1d4ed8;
            color: white;
        }

        /* 기간조회 모달 스타일 */
        .global-settings-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .global-checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            color: #374151;
            font-size: 1rem;
        }

        .global-checkmark {
            width: 22px;
            height: 22px;
            border: 2px solid #6b7280;
            border-radius: 4px;
            position: relative;
            transition: all 0.2s ease;
            background: #ffffff;
        }

        .global-checkbox-label input[type="checkbox"] {
            display: none;
        }

        .global-checkbox-label input[type="checkbox"]:checked + .global-checkmark {
            background: #3b82f6;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .global-checkbox-label input[type="checkbox"]:checked + .global-checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .individual-period-settings {
            margin-top: 1rem;
        }

        .individual-period-settings .query-panel {
            background: linear-gradient(135deg, var(--primary-blue), var(--primary-purple));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* 기간조회 모달 넓이 조정 */
        #periodQueryModal .modal-content {
            max-width: 600px;
            width: 80%;
            max-height: fit-content;
            margin: 2% auto;
        }

        /* 조회 패널 내부 요소들이 1줄로 표시되도록 */
        .individual-period-settings .query-panel .query-mode {
            flex-wrap: nowrap;
            gap: 0.5rem;
        }

        .individual-period-settings .query-panel .datetime-inputs {
            flex-shrink: 0;
        }

        .individual-period-settings .query-panel .duration-badge {
            min-width: 120px;
        }

        .individual-period-settings .query-panel .interval-select {
            min-width: 80px;
        }

        /* 조회 패널 텍스트 크기 증가 */
        .individual-period-settings .query-panel {
            font-size: 14px;
        }

        .individual-period-settings .query-panel label {
            font-size: 14px !important;
            font-weight: 600;
        }

        .individual-period-settings .query-panel select {
            font-size: 14px !important;
            padding: 8px 12px;
        }

        .individual-period-settings .query-panel input[type="text"],
        .individual-period-settings .query-panel input[type="datetime-local"] {
            font-size: 14px !important;
            padding: 8px 12px;
        }

        .individual-period-settings .query-panel .radio-label {
            font-size: 14px !important;
        }

        .individual-period-settings .query-panel .btn {
            font-size: 14px !important;
            padding: 8px 16px;
        }

        .chart-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chart-icon {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 8px;
        }

        .chart-icon.stt { background: var(--stt-primary); }
        .chart-icon.tts { background: var(--tts-primary); }
        .chart-icon.sv { background: var(--sv-primary); }


        .engine-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .engine-badge.stt {
            background: rgba(59, 130, 246, 0.1);
            color: #1d4ed8;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .engine-badge.tts {
            background: rgba(139, 92, 246, 0.1);
            color: #7c3aed;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .engine-badge.sv {
            background: rgba(245, 158, 11, 0.1);
            color: #d97706;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .category-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.6rem;
            font-weight: 500;
            background: rgba(107, 114, 128, 0.1);
            color: #4b5563;
            border: 1px solid rgba(107, 114, 128, 0.3);
        }


        .max-value-display {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            background: var(--bg-tertiary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid var(--border-color);
            font-size: 0.75rem;
        }

        .max-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .max-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--warning-color);
        }

        .chart-type-selector {
            display: flex;
            align-items: center;
        }

        .chart-type-dropdown {
            padding: 0.25rem 0.4rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            background: white;
            font-size: 0.75rem;
            color: var(--text-primary);
            cursor: pointer;
            min-width: 60px;
        }

        .chart-type-dropdown:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .chart-controls {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .x-axis-range-control {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .x-axis-input {
            width: 50px;
            padding: 0.2rem 0.3rem;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: white;
            color: var(--text-secondary);
            font-size: 0.7rem;
            text-align: center;
        }

        .x-axis-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .x-axis-range-control span {
            color: var(--text-secondary);
            font-size: 0.7rem;
            font-weight: 500;
        }

        .chart-action-btn {
            width: 20px;
            height: 20px;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .chart-action-btn:hover {
            background: var(--primary-blue);
            color: white;
        }

        /* JSON 액션 버튼 */
        .json-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .json-btn {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .json-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .json-btn:active {
            transform: translateY(0);
        }

        .json-btn i {
            font-size: 0.7rem;
        }

        .settings-btn {
            background: var(--primary-blue);
            color: white;
        }

        .settings-btn:hover {
            background: #2563eb;
        }

        /* 차트 설정 모달 */
        .chart-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
        }

        .settings-modal-content {
            background: var(--bg-primary);
            margin: 3% auto;
            padding: 1.5rem;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* 차트 설정 모달 기본 스타일 */
        .chart-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
        }

        .settings-modal-content {
            background: white;
            margin: 1% auto;
            padding: 1rem;
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            height: 98vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
        }

        .modal-title {
            margin: 0;
            color: #495057;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 0.5rem 0 1rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
        }

        .modal-close:hover {
            color: #495057;
        }

        /* 미리보기 섹션 */
        .preview-section {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .preview-section h4 {
            margin: 0 0 0.5rem 0;
            color: #495057;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .preview-chart-container {
            background: white;
            border-radius: 4px;
            padding: 0.5rem;
            border: 1px solid #dee2e6;
        }

        /* 설정 그룹 */
        .setting-group {
            margin-bottom: 0.15rem;
            padding: 0.15rem 0.25rem;
            background: transparent;
            border-radius: 0;
            border: none;
        }

        .setting-group h4 {
            margin: 0 0 0.05rem 0;
            color: #495057;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .setting-description {
            margin: 0.02rem 0 0 0;
            color: #6c757d;
            font-size: 0.7rem;
        }

        /* 라디오 그룹 */
        .radio-group {
            display: flex;
            gap: 0.3rem;
            flex-wrap: wrap;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 0.15rem;
            cursor: pointer;
            font-size: 0.7rem;
            color: #495057;
        }

        .radio-label i {
            font-size: 0.8rem;
            color: #6c757d;
        }

        .radio-mark {
            width: 12px;
            height: 12px;
            border: 1.5px solid #6c757d;
            border-radius: 50%;
            position: relative;
            background: white;
            transition: all 0.2s ease;
        }

        .radio-label input[type="radio"] {
            display: none;
        }

        .radio-label input[type="radio"]:checked + .radio-mark {
            border-color: #007bff;
            background: #007bff;
        }

        .radio-label input[type="radio"]:checked + .radio-mark::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: white;
        }

        .radio-label input[type="radio"]:checked ~ i {
            color: #007bff;
        }

        /* 토글 스위치 */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .toggle-with-description {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }
        

        .toggle-label {
            position: relative;
            display: inline-block;
            width: 32px;
            height: 16px;
            cursor: pointer;
        }

        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 16px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 10px;
            width: 10px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-label input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-label input:checked + .toggle-slider {
            background-color: #007bff;
        }

        .toggle-label input:checked + .toggle-slider:before {
            transform: translateX(16px);
        }

        .toggle-text {
            font-size: 0.7rem;
            font-weight: 600;
            color: #495057;
        }

        /* Y축 고정 입력 */
        .y-axis-fixed-input {
            margin-top: 0.25rem;
            padding: 0.2rem;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .y-axis-fixed-input label {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            color: #495057;
        }

        .y-axis-fixed-input input {
            width: 60px;
            padding: 0.2rem 0.4rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        /* 임계치 아이템 */
        .threshold-item {
            margin-bottom: 0.15rem;
            padding: 0.15rem;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .threshold-item .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.7rem;
            color: #495057;
            cursor: pointer;
            flex-wrap: wrap;
        }
        
        .threshold-description {
            font-size: 0.6rem;
            color: #6c757d;
            margin-left: 0.5rem;
        }

        .threshold-item .checkmark {
            width: 12px;
            height: 12px;
            border: 1.5px solid #6c757d;
            border-radius: 2px;
            position: relative;
            background: white;
            transition: all 0.2s ease;
        }

        .threshold-item input[type="checkbox"] {
            display: none;
        }

        .threshold-item input[type="checkbox"]:checked + .checkmark {
            background: #007bff;
            border-color: #007bff;
        }

        .threshold-item input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .threshold-item input[type="number"] {
            width: 40px;
            padding: 0.15rem 0.3rem;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 0.7rem;
            margin: 0 0.15rem;
        }

        /* 푸터 */
        .settings-footer {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin: 0.5rem 1rem 0.5rem 1rem;
            padding: 0.5rem 0;
            border-top: 1px solid #dee2e6;
            flex-shrink: 0;
        }

        .btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-secondary {
            background: white;
            color: #007bff;
            border: 1px solid #007bff;
        }

        .btn-secondary:hover {
            background: #f8f9fa;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .settings-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .settings-section {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
            background: var(--bg-secondary);
        }

        .settings-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .settings-row:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .settings-input {
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: white;
            color: var(--text-secondary);
            font-size: 0.8rem;
            min-width: 120px;
        }

        .settings-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .settings-select {
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: white;
            color: var(--text-secondary);
            font-size: 0.8rem;
            min-width: 120px;
        }

        .settings-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .settings-btn-primary {
            padding: 0.5rem 1rem;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .settings-btn-primary:hover {
            background: #2563eb;
        }

        .settings-btn-secondary {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .settings-btn-secondary:hover {
            background: var(--border-color);
        }

        /* 서버별 설정 모달 */
        .server-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
        }

        .server-settings-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            max-height: 70vh;
            overflow-y: auto;
        }

        .server-type-section {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            background: var(--bg-secondary);
        }

        .server-type-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .server-type-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .server-type-icon.stt { background: var(--stt-primary); }
        .server-type-icon.tts { background: var(--tts-primary); }
        .server-type-icon.sv { background: var(--sv-primary); }
        .server-type-icon.common { background: var(--hw-primary); }

        .server-type-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .server-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }


        .server-item.selected {
            background: #e3f2fd;
            border-color: #2563eb;
        }

        .server-item.unselected {
            background: #f8f9fa;
            border-color: #e9ecef;
            opacity: 0.7;
        }

        .server-item:hover {
            background: #e9ecef;
            border-color: #dee2e6;
        }

        .server-item.selected:hover {
            background: #e3f2fd;
            border-color: #2563eb;
        }

        .server-checkbox {
            display: flex;
            align-items: center;
            margin-right: 0.4rem;
        }

        .server-checkbox input[type="checkbox"] {
            margin: 0;
            margin-right: 0.4rem;
        }

        /* 서버 리스트 컨테이너 */
        .server-list-container {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.3rem;
            align-items: center;
            overflow-x: auto;
            padding: 0.2rem 0;
        }

        .server-group-section {
            display: flex;
            flex-direction: row;
            gap: 0.3rem;
            align-items: center;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 0.3rem 0.5rem;
            margin-bottom: 0;
            flex-shrink: 0;
            min-width: fit-content;
        }

        .server-group-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.75rem;
            color: white;
            min-width: 50px;
            justify-content: center;
        }

        .server-group-label.stt {
            background: var(--stt-primary);
        }

        .server-group-label.tts {
            background: var(--tts-primary);
        }

        .server-group-label.sv {
            background: var(--sv-primary);
        }

        .server-group-servers {
            display: flex;
            gap: 0.3rem;
            flex-wrap: nowrap;
        }

        /* 서버 아이템 스타일 개선 */
        .server-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.3rem 0.5rem;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            transition: all 0.2s ease;
            min-width: 100px;
            flex-shrink: 0;
            position: relative;
        }

        .server-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            border-radius: 2px 0 0 2px;
        }

        .server-item.stt::before {
            background: var(--stt-primary);
        }

        .server-item.tts::before {
            background: var(--tts-primary);
        }

        .server-item.sv::before {
            background: var(--sv-primary);
        }

        .server-info {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex: 1;
        }

        .server-name {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .server-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }

        .server-status.warning { background: var(--warning); }
        .server-status.error { background: var(--error); }

        .server-actions {
            display: flex;
            gap: 0.25rem;
        }

        .server-item-action-btn {
            width: 20px;
            height: 20px;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .server-item-action-btn:hover {
            background: var(--primary-blue);
            color: white;
        }

        /* 대시보드 관리 모달 */
        .dashboard-management-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        /* 대시보드 수정 모달 */
        .edit-dashboard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2001;
            align-items: center;
            justify-content: center;
        }

        .dashboard-management-content {
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }

        .dashboard-management-body {
            padding: 0;
            max-height: calc(90vh - 60px);
            overflow-y: auto;
        }

        .dashboard-section {
            margin-bottom: 2rem;
        }

        .dashboard-section-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding: 0 1.5rem;
            justify-content: space-between;
        }

        .dashboard-section-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .admin-icon {
            background: #f59e0b;
        }

        .personal-icon {
            background: #10b981;
        }

        .dashboard-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin: 0;
        }

        .new-dashboard-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .new-dashboard-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .new-dashboard-btn i {
            font-size: 0.75rem;
        }

        .dashboard-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 0 1.5rem;
        }

        .dashboard-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            background: white;
            transition: all 0.2s;
            min-height: 60px;
            position: relative;
        }

        .dashboard-item:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        .dashboard-item:hover .dashboard-actions-hover {
            opacity: 1;
            visibility: visible;
        }

        .dashboard-item.selected {
            background: #f3f4f6;
            border-color: #3b82f6;
        }

        .dashboard-checkbox {
            margin-right: 1rem;
        }

        .dashboard-info {
            flex: 1;
            min-width: 0;
            margin-right: 80px; /* 버튼 영역을 위한 여백 */
        }

        .dashboard-name {
            font-weight: 600;
            color: #111827;
            margin-bottom: 0.25rem;
            font-size: 0.95rem;
        }

        .dashboard-description {
            font-size: 0.8rem;
            color: #6b7280;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
        }

        .dashboard-actions {
            display: flex;
            gap: 0.75rem;
            padding: 1.5rem;
            border-top: 1px solid #e5e7eb;
            align-items: center;
            justify-content: space-between;
        }

        .action-buttons-left {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .action-buttons-right {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .dashboard-actions-hover {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
        }

        .dashboard-status {
            color: #10b981;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            padding: 0.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            font-weight: 500;
            min-width: 28px;
            height: 28px;
        }

        .action-btn.modify-btn {
            background: #f3f4f6;
            color: #374151;
        }

        .action-btn.modify-btn:hover {
            background: #e5e7eb;
            color: #111827;
        }

        .action-btn.default-btn {
            background: #fef3c7;
            color: #d97706;
        }

        .action-btn.default-btn:hover {
            background: #fde68a;
            color: #b45309;
        }

        .action-btn.export-btn {
            background: #3b82f6;
            color: white;
        }

        .action-btn.export-btn:hover:not(:disabled) {
            background: #2563eb;
            color: white;
        }

        .action-btn.import-btn {
            background: #10b981;
            color: white;
        }

        .action-btn.import-btn:hover {
            background: #059669;
            color: white;
        }

        .action-btn.delete-btn {
            background: #ef4444;
            color: white;
        }

        .action-btn.delete-btn:hover:not(:disabled) {
            background: #dc2626;
            color: white;
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .action-btn:hover:not(:disabled) {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #f3f4f6;
            border-color: #e5e7eb;
            color: #9ca3af;
        }

        .delete-btn {
            background: #dc2626;
            border-color: #dc2626;
            color: white;
        }

        .delete-btn:hover:not(:disabled) {
            background: #b91c1c;
            border-color: #b91c1c;
        }

        .delete-btn:disabled {
            background: #f3f4f6;
            border-color: #e5e7eb;
            color: #9ca3af;
        }

        .delete-btn.active {
            background: #dc2626;
            border-color: #dc2626;
            color: white;
        }

        .delete-btn.inactive {
            background: #f3f4f6;
            border-color: #e5e7eb;
            color: #9ca3af;
        }

        .export-btn {
            background: #f3f4f6;
        }

        .import-btn {
            background: white;
        }

        .delete-btn {
            background: #fef2f2;
            border-color: #fca5a5;
            color: #dc2626;
        }

        .delete-btn:hover:not(:disabled) {
            background: #fee2e2;
            border-color: #f87171;
        }

        .create-dashboard-section {
            border-top: 1px solid #e5e7eb;
            background: #f9fafb;
        }

        .create-dashboard-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.5rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .create-dashboard-header:hover {
            background: #f3f4f6;
        }

        .create-dashboard-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin: 0;
        }

        .create-dashboard-toggle {
            color: #6b7280;
            transition: transform 0.2s;
        }

        .create-dashboard-toggle.rotated {
            transform: rotate(180deg);
        }

        .create-dashboard-content {
            padding: 0 1.5rem 1.5rem;
            display: none;
        }

        .create-dashboard-content.expanded {
            display: block;
        }

        .create-dashboard-buttons {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .dashboard-type-section {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            background: var(--bg-secondary);
        }

        .dashboard-type-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .dashboard-type-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .dashboard-type-icon.admin { background: #f59e0b; }
        .dashboard-type-icon.personal { background: #10b981; }
        .dashboard-type-icon.default { background: var(--primary-blue); }

        .dashboard-type-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .dashboard-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .dashboard-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dashboard-item:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
        }

        .dashboard-item.active {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .dashboard-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .dashboard-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .dashboard-description {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .dashboard-actions {
            display: flex;
            gap: 0.25rem;
        }

        .dashboard-list-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .dashboard-list-btn:hover {
            background: var(--primary-blue);
            color: white;
        }


        .metric-value {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.125rem;
        }

        .metric-label {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .metric-value.requests { color: var(--info); }
        .metric-value.success { color: var(--success); }
        .metric-value.error { color: var(--error); }
        .metric-value.warning { color: var(--warning); }

        /* 차트 컨테이너 */
        .chart-container {
            flex: 1;
            min-height: 200px;
            position: relative;
            width: 100%;
            height: 200px;
        }

        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* 모달 */
        .detail-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
        }

        .modal-content {
            background: var(--bg-primary);
            margin: 2% auto;
            padding: 1.5rem;
            border-radius: 8px;
            width: 90%;
            height: 85%;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .modal-chart {
            flex: 1;
            position: relative;
        }

        /* 임계치 설정 패널 */
        .threshold-panel {
            position: absolute;
            top: 50px;
            right: 10px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 1001;
            min-width: 280px;
            display: none;
        }

        .threshold-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .threshold-content {
            padding: 1rem;
        }

        .threshold-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .threshold-item:last-child {
            margin-bottom: 0;
        }

        .threshold-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .threshold-input {
            width: 80px;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 0.75rem;
        }


        /* 헤더 액션 버튼 */
        .header-action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .header-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .header-action-btn:active {
            transform: translateY(0);
        }

        /* 작은 버튼 스타일 */
        .header-action-btn.small {
            padding: 0.3rem 0.6rem;
            font-size: 0.65rem;
            gap: 0.3rem;
        }

        .header-action-btn.small i {
            font-size: 0.6rem;
        }

        .header-action-btn.small span {
            font-size: 0.6rem;
        }

        .view-action-btn i {
            font-size: 0.7rem;
        }

        /* 내보내기/가져오기 모달 */
        .export-modal, .import-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
        }

        .import-modal.show {
            display: flex !important;
        }

        .export-modal .modal-content, .import-modal .modal-content {
            background: var(--bg-primary);
            margin: 5% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .modal-body {
            padding: 1.5rem;
        }

        .export-info p {
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }

        .export-details {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .detail-item:last-child {
            margin-bottom: 0;
        }

        .detail-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .detail-value {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .checkbox-label input[type="checkbox"] {
            display: none;
        }

        .checkmark {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .checkbox-label input[type="checkbox"]:checked + .checkmark {
            background: var(--primary-blue);
            border-color: var(--primary-blue);
        }

        .checkbox-label input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            padding: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        /* 모달 기본 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            overflow: hidden;
        }

        /* 임계치 설정 모달 스타일 */
        .threshold-modal {
            max-width: 400px;
            width: 90%;
        }

        .threshold-modal .modal-header {
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            padding: 1.5rem;
            margin: 0;
        }

        .threshold-modal .modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: #1e293b;
        }

        .threshold-modal .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #64748b;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .threshold-modal .close-btn:hover {
            color: #1e293b;
        }

        .threshold-modal .modal-body {
            padding: 1.5rem 1.5rem 1rem 1.5rem;
        }

        .modal-description {
            font-size: 0.875rem;
            color: #64748b;
            margin: 0 0 1.5rem 0;
            line-height: 1.5;
        }

        .threshold-settings {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .threshold-item {
            padding: 0;
            border: none;
            background: none;
        }

        .threshold-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .threshold-header input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            accent-color: #3b82f6;
        }

        .threshold-header label {
            font-weight: 500;
            color: #374151;
            margin: 0;
            cursor: pointer;
        }

        .threshold-header input[type="number"] {
            width: 60px;
            padding: 0.375rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            text-align: center;
        }

        .threshold-header input[type="number"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .unit {
            font-weight: 500;
            color: #6b7280;
            font-size: 0.875rem;
        }

        .threshold-description {
            font-size: 0.75rem;
            color: #6b7280;
            margin: 0;
            margin-left: 1.75rem;
        }

        .threshold-modal .modal-footer {
            padding: 0.5rem 1.5rem 0.5rem 1.5rem;
            border-top: 1px solid #e2e8f0;
            background: #f8fafc;
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin: 0;
        }

        .threshold-modal .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .threshold-modal .btn-secondary {
            background: #f1f5f9;
            color: #475569;
            border: 1px solid #cbd5e1;
        }

        .threshold-modal .btn-secondary:hover {
            background: #e2e8f0;
        }

        .threshold-modal .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .threshold-modal .btn-primary:hover {
            background: #2563eb;
        }

        /* 조회설정 모달 스타일 */
        .large-modal .modal-content {
            max-width: 600px;
            width: 90%;
        }

        .accordion {
            display: flex;
            flex-direction: column;
        }

        .accordion-item {
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }

        .accordion-item.active {
            border-color: var(--primary-blue);
        }

        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--bg-tertiary);
            cursor: pointer;
            user-select: none;
        }

        .accordion-header h4 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .accordion-header i {
            transition: transform 0.3s ease;
        }

        .accordion-item.active .accordion-header i {
            transform: rotate(180deg);
        }

        .accordion-content {
            display: none;
            padding: 1rem;
            background: white;
        }

        .accordion-item.active .accordion-content {
            display: block;
        }

        .query-period-settings {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .time-range-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .time-range-header {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .realtime-btn {
            padding: 0.5rem 1rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .realtime-btn:hover {
            background: #2563eb;
        }

        .time-range-display {
            padding: 0.5rem 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            text-align: center;
            font-weight: 500;
            font-size: 0.875rem;
            color: #374151;
            flex: 1;
        }

        .duration-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: center;
        }

        .duration-controls input {
            width: 60px;
            padding: 0.375rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            text-align: center;
            font-size: 0.875rem;
        }

        .duration-controls input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .duration-controls span {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .nav-btn {
            padding: 0.375rem 0.5rem;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: #374151;
        }

        .nav-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .data-interval-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .data-interval-section label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }

        .data-interval {
            padding: 0.375rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background: white;
        }

        .data-interval:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .custom-period-settings {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
        }

        .custom-time-settings {
            margin-top: 1rem;
            padding: 1rem;
            background: #f1f5f9;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
        }

        .time-picker-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .time-picker-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .time-picker-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }

        .datetime-picker {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            position: relative;
        }

        .datetime-picker input[type="date"],
        .datetime-picker input[type="time"] {
            padding: 0.375rem 3rem 0.375rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background: white;
            width: 160px;
            cursor: pointer;
        }

        .datetime-picker input[type="date"]:focus,
        .datetime-picker input[type="time"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .date-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .time-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .input-icon {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 1.2rem;
            color: #374151;
            z-index: 10;
            background: white;
            padding: 0.2rem;
            border-radius: 0.25rem;
        }

        .y-axis-settings {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .radio-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .radio-group input[type="number"] {
            width: 80px;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
        }

        .time-series-settings {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .comparison-settings {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .comparison-settings select {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
        }

        .color-settings {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .color-picker {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
        }

        .color-picker input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
        }

        /* 상세보기 모달 스타일 */
        .fullscreen-modal {
            z-index: 10000 !important;
        }
        
        .fullscreen-modal .modal-content {
            width: 95%;
            height: 95%;
            max-width: none;
            max-height: none;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 10001;
        }

        .fullscreen-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #ffffff;
        }

        .detail-chart-container {
            flex: 1;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 1rem;
            position: relative;
        }

        .detail-chart-container canvas {
            width: 100% !important;
            height: 100% !important;
            border-radius: 8px;
        }

        /* 상세보기 모달 헤더 스타일 */
        .fullscreen-modal .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fullscreen-modal .modal-header h3 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .fullscreen-modal .close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .fullscreen-modal .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* 범례/서버선택 모달 스타일 */
        .legend-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 0.5rem;
        }

        .legend-server-controls {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .legend-server-actions {
            display: flex;
            gap: 0.5rem;
        }

        .server-selection-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.5rem;
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            background: #f9fafb;
        }

        .server-selection-list .server-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .server-selection-list .server-item:hover {
            background: #f3f4f6;
            border-color: #3b82f6;
        }

        .server-selection-list .server-item.selected {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .server-selection-list .server-item input[type="checkbox"] {
            margin: 0;
            pointer-events: none;
        }

        .server-selection-list .server-item label {
            margin: 0;
            cursor: pointer;
            flex: 1;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .btn-primary, .btn-secondary {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--primary-blue);
            color: white;
            border: none;
        }

        .btn-primary:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-secondary);
        }

        /* 가져오기 대상 선택 섹션 */
        .import-destination-section, .export-destination-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: block !important; /* 강제 표시 */
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 1rem;
        }

        .destination-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .destination-option {
            display: block;
            cursor: pointer;
        }

        .destination-option input[type="radio"] {
            display: none;
        }

        .option-content {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            transition: all 0.2s ease;
            background: white;
        }

        .destination-option input[type="radio"]:checked + .option-content {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .option-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .option-icon.admin-icon {
            background: #fef3c7;
            color: #d97706;
        }

        .option-icon.personal-icon {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .option-icon.download-icon {
            background: #dcfce7;
            color: #16a34a;
        }

        .option-icon.custom-icon {
            background: #fef3c7;
            color: #d97706;
        }

        .option-text {
            flex: 1;
        }

        .option-title {
            font-weight: 600;
            color: #111827;
            margin-bottom: 0.25rem;
        }

        .option-desc {
            font-size: 0.875rem;
            color: #6b7280;
        }

        /* 가져오기 업로드 영역 */
        .import-upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-secondary);
        }

        .import-upload-area:hover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .import-upload-area.dragover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
        }

        .upload-icon {
            font-size: 2rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .upload-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .upload-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .import-preview {
            margin-top: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-header {
            background: var(--bg-secondary);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .preview-content {
            padding: 1rem;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            background: #f8f9fa;
        }

        /* 대시보드 관리 모달 스타일 */
        .dashboard-selection-section,
        .export-import-section {
            margin-bottom: 2rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* 삭제 확인 모달 스타일 */
        .delete-confirm-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .delete-confirm-modal .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            animation: modalSlideIn 0.3s ease-out;
        }

        .delete-warning {
            text-align: center;
            padding: 2rem;
        }

        .delete-warning i {
            font-size: 3rem;
            color: #f59e0b;
            margin-bottom: 1rem;
        }

        .delete-warning p {
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .delete-dashboard-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--primary-blue);
        }

        .delete-warning-text {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            padding: 1rem 2rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 0 0 12px 12px;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* 새 대시보드 생성 모달 스타일 */
        .create-dashboard-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .create-dashboard-modal .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            animation: modalSlideIn 0.3s ease-out;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.2s ease;
        }

        .form-input:focus,
        .form-textarea:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn-primary {
            background: var(--primary-blue);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .dashboard-radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .dashboard-radio-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dashboard-radio-item:hover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .dashboard-radio-item.selected {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
        }

        .dashboard-checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dashboard-checkbox-item:hover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .dashboard-checkbox-item.selected {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
        }

        .dashboard-checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .dashboard-checkbox-info {
            flex: 1;
        }

        .dashboard-checkbox-name {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .dashboard-checkbox-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* 대시보드 유형별 그룹 스타일 */
        .dashboard-type-group {
            margin-bottom: 1.5rem;
        }

        .dashboard-type-group:last-child {
            margin-bottom: 0;
        }

        .dashboard-type-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .dashboard-type-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
        }

        .dashboard-type-icon.admin {
            background: #f59e0b;
        }

        .dashboard-type-icon.personal {
            background: #10b981;
        }

        .dashboard-type-icon.default {
            background: var(--primary-blue);
        }

        .dashboard-type-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .dashboard-type-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .dashboard-radio-item input[type="radio"] {
            margin: 0;
        }

        .dashboard-radio-info {
            flex: 1;
        }

        .dashboard-radio-name {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .dashboard-radio-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .export-import-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }

        .dashboard-action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            white-space: nowrap;
            min-width: fit-content;
            flex-shrink: 0;
        }

        .export-btn {
            background: var(--primary-blue);
            color: white;
        }

        .export-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .import-btn {
            background: var(--success);
            color: white;
        }

        .delete-btn {
            background: #ef4444;
            color: white;
        }

        .delete-btn:hover:not(:disabled) {
            background: #dc2626;
        }

        .delete-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .import-btn:hover {
            background: #059669;
            transform: translateY(-1px);
        }

        .dashboard-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .dashboard-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .dashboard-list-info {
            flex: 1;
        }

        .dashboard-list-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .dashboard-list-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .dashboard-list-actions {
            display: flex;
            gap: 0.5rem;
        }

        .dashboard-list-btn {
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-color);
            background: white;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dashboard-list-btn:hover {
            background: var(--bg-tertiary);
        }

        .dashboard-list-btn.delete-btn {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        .dashboard-list-btn.delete-btn:hover {
            background: #dc2626;
            border-color: #dc2626;
            transform: translateY(-1px);
        }

        /* 반응형 */
        @media (max-width: 768px) {
            .container {
                padding: 0.75rem;
            }
            
            .control-panel {
                flex-direction: column;
                align-items: stretch;
                gap: 0.75rem;
            }
            
            .control-left, .control-right {
                justify-content: center;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
            
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="header-title">
                <i class="fas fa-chart-network"></i>
                <h1>AMP 모니터링</h1>
            </div>
            
            <!-- 조회 기능 패널 -->
            <div class="query-panel">
                <div class="realtime-mode" id="realtimeMode" style="display: none;">
                    <button class="query-btn stop-btn" onclick="stopRealtime()" title="실시간 모니터링 중지">
                        <i class="fas fa-stop"></i>
                        정지
                    </button>
                    <div class="realtime-status">
                        <div class="status-indicator">
                            <div class="pulse-circle"></div>
                        </div>
                        <span>실시간 감시중</span>
                    </div>
                    <select class="refresh-interval" id="refreshInterval" onchange="changeRefreshInterval(this.value)">
                        <option value="5m" selected>실시간 5분</option>
                        <option value="10m">실시간 10분</option>
                        <option value="1h">실시간 1시간</option>
                    </select>
                </div>
                
                <div class="query-mode" id="queryMode">
                    <button class="query-btn start-btn" onclick="startRealtime()" title="실시간 모니터링 시작">
                        <i class="fas fa-play"></i>
                        실시간
                    </button>
                    <div class="datetime-inputs">
                        <input type="datetime-local" class="datetime-input" id="startDateTime">
                        <span class="range-separator">~</span>
                        <input type="datetime-local" class="datetime-input" id="endDateTime">
                    </div>
                    <select class="duration-badge" id="durationBadge" onchange="changeDuration(this.value)">
                        <option value="5m">최근 5분</option>
                        <option value="10m">최근 10분</option>
                        <option value="1h" selected>최근 1시간</option>
                        <option value="3h">최근 3시간</option>
                        <option value="1d">최근 1일</option>
                        <option value="7d">최근 7일</option>
                        <option value="30d">최근30일</option>
                        <option value="today">오늘(00 ~ 24)</option>
                        <option value="yesterday">어제(00 ~ 24)</option>
                        <option value="start-5m">시작시간 ~ 5분</option>
                        <option value="start-10m">시작시간 ~ 10분</option>
                        <option value="start-1h">시작시간 ~ 1시간</option>
                    </select>
                    <span class="interval-label">간격</span>
                    <select class="interval-select" id="timeInterval" onchange="setupIntervalListener()">
                        <option value="1m">1분</option>
                        <option value="5m" selected>5분</option>
                        <option value="15m">15분</option>
                        <option value="30m">30분</option>
                        <option value="1h">1시간</option>
                    </select>
                    <button class="query-btn execute-btn" onclick="executeQuery()" title="조회 실행">
                        <i class="fas fa-search"></i>
                        조회
                    </button>
                </div>
            </div>
            
            <!-- 대시보드 선택 패널 -->
            <div class="dashboard-selection-panel">
                <!-- 대시보드 모드 선택 -->
                <div class="selection-group">
                    <div class="selection-label">대시보드 모드 선택</div>
                    <div class="mode-buttons">
                        <button class="mode-btn" id="viewModeBtn" onclick="setViewMode()">뷰모드</button>
                        <button class="mode-btn active" id="editModeBtn" onclick="setEditMode()">수정모드</button>
                    </div>
                </div>
                
                <div class="selection-divider"></div>
                
                <!-- 대시보드 유형 선택 -->
                <div class="selection-group">
                    <div class="selection-label">대시보드 유형 선택</div>
                    <div class="dashboard-type-buttons">
                        <button class="type-btn" id="publicTypeBtn" onclick="setDashboardType('public')">공용</button>
                        <button class="type-btn active" id="personalTypeBtn" onclick="setDashboardType('personal')">개인</button>
                        <select class="dashboard-dropdown" id="dashboardSelect" onchange="selectDashboard(this.value)">
                            <option value="personal1">1.대시보드</option>
                            <option value="personal2">2.대시보드</option>
                            <option value="personal3" selected>3.대시보드</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="header-info">
                <!-- 컨트롤 버튼들 -->
                <button class="header-action-btn small" id="engineListToggle" onclick="toggleEngineList()" style="display: none;" title="엔진 목록">
                    <i class="fas fa-cogs"></i>
                    <span>엔진</span>
                </button>
                <button class="header-action-btn small" id="serverListToggle" onclick="toggleServerList()" title="서버 목록">
                    <i class="fas fa-server"></i>
                    <span>서버</span>
                </button>
                
                <!-- 대시보드 관리 버튼 -->
                <button class="header-action-btn" onclick="openDashboardManagement()" title="대시보드 관리">
                    <i class="fas fa-cog"></i>
                    대시보드 관리
                </button>
                
                <!-- 시간 표시 (맨 오른쪽) -->
                <div class="time-display">
                    <i class="fas fa-clock"></i>
                    <span id="currentTime">--:--:--</span>
                </div>
            </div>
        </div>
    </header>


    <!-- 메인 컨테이너 -->
    <div class="container" id="mainContainer">
        <!-- 카드 표시 옵션 패널 (수정 모드에서만 표시) -->
        <div class="card-options-panel" id="cardOptionsPanel">
            <div class="options-header">
                <div class="options-title">엔진 항목 선택</div>
                <div class="edit-mode-actions">
                    <button class="edit-action-btn secondary" onclick="resetEditChanges()">
                        <i class="fas fa-undo"></i>
                        초기화
                    </button>
                    <button class="edit-action-btn primary" onclick="applyEditChanges()">
                        <i class="fas fa-save"></i>
                        저장
                    </button>
                </div>
            </div>
            <div class="options-grid" id="optionsGrid">
                <!-- 동적으로 생성됩니다 -->
            </div>
        </div>

        <!-- 서버 선택 패널 -->
        <div class="server-selection-panel" id="serverSelectionPanel">
            <div class="server-panel-header">
                <div class="server-panel-title">
                    <i class="fas fa-server"></i>
                    <span>서버 목록 (<span id="serverCount">총 20개, 선택 16개</span>)</span>
                </div>
                <div class="server-panel-actions">
                    <button class="server-action-btn" onclick="selectAllServers()">
                        <i class="fas fa-check-double"></i>
                        전체 선택
                    </button>
                    <button class="server-action-btn" onclick="deselectAllServers()">
                        <i class="fas fa-times"></i>
                        전체 해제
                    </button>
                </div>
            </div>
            <div class="server-list-container" id="serverListContainer">
                <!-- 모든 서버들이 한줄로 나열됩니다 -->
            </div>
        </div>
        
        <!-- 차트 그리드 -->
        <div class="charts-grid" id="chartsGrid">
            <!-- 차트들이 동적으로 생성됩니다 -->
        </div>
    </div>

    <!-- 상세 정보 모달 -->
    <div class="detail-modal" id="detailModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">상세 정보</h3>
                <button class="modal-close" onclick="closeDetailModal()">&times;</button>
            </div>
            <div class="modal-chart" id="modalChart"></div>
        </div>
    </div>

    <!-- 차트 설정 모달 -->
    <div class="chart-settings-modal" id="chartSettingsModal">
        <div class="modal-content settings-modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="chartSettingsTitle">차트 설정</h3>
                <button class="modal-close" onclick="closeChartSettings()">&times;</button>
            </div>
            <div class="settings-content" id="chartSettingsContent">
                <!-- 미리보기 차트 -->
                <div class="preview-section">
                    <h4>미리보기</h4>
                    <div class="preview-chart-container">
                        <canvas id="previewChart" width="400" height="150"></canvas>
                    </div>
                </div>

                <!-- 차트 유형 설정 -->
                <div class="setting-group">
                    <h4>차트 유형</h4>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="chartType" value="line" onchange="updatePreviewChart()">
                            <span class="radio-mark"></span>
                            <i class="fas fa-chart-line"></i>
                            선차트
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="chartType" value="bar" onchange="updatePreviewChart()">
                            <span class="radio-mark"></span>
                            <i class="fas fa-chart-bar"></i>
                            막대차트
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="chartType" value="area" checked onchange="updatePreviewChart()">
                            <span class="radio-mark"></span>
                            <i class="fas fa-chart-area"></i>
                            영역차트
                        </label>
                    </div>
                </div>

                <!-- 이전 시간과 비교 -->
                <div class="setting-group">
                    <h4>이전 시간과 비교</h4>
                    <div class="toggle-switch">
                        <label class="toggle-label">
                            <input type="checkbox" id="comparePrevious" onchange="updatePreviewChart()">
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-text" id="compareText">OFF</span>
                    </div>
                </div>

                <!-- Y축 최대값 설정 -->
                <div class="setting-group">
                    <h4>Y축 최대값</h4>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="yAxisMax" value="auto" checked onchange="toggleYAxisFixed(); updatePreviewChart();">
                            <span class="radio-mark"></span>
                            자동
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="yAxisMax" value="fixed" onchange="toggleYAxisFixed(); updatePreviewChart();">
                            <span class="radio-mark"></span>
                            고정
                        </label>
                    </div>
                    <div class="y-axis-fixed-input" id="yAxisFixedInput" style="display: none;">
                        <label>최대값: <input type="number" id="yAxisMaxValue" value="100" onchange="updatePreviewChart()"></label>
                    </div>
                </div>

                <!-- 최대값 표시 -->
                <div class="setting-group">
                    <h4>최대값 표시</h4>
                    <div class="toggle-switch">
                        <div class="toggle-with-description">
                            <label class="toggle-label">
                                <input type="checkbox" id="showMaxValue" checked onchange="updatePreviewChart()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-text" id="maxValueText">ON</span>
                            <span class="threshold-description">차트에서 MAX 값을 가진 서버의 값을 차트위에 표시함</span>
                        </div>
                    </div>
                </div>

                <!-- 범례 표시 -->
                <div class="setting-group">
                    <h4>범례 표시</h4>
                    <div class="toggle-switch">
                        <div class="toggle-with-description">
                            <label class="toggle-label">
                                <input type="checkbox" id="showLegend" checked onchange="updatePreviewChart()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-text" id="legendText">ON</span>
                            <span class="threshold-description">설정 시 차트내에 서버리스트를 표시해 줍니다.</span>
                        </div>
                    </div>
                </div>

                <!-- 임계치 설정 -->
                <div class="setting-group">
                    <h4>임계치 설정</h4>
                    
                    <div class="threshold-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showMaxThreshold" checked onchange="updatePreviewChart()">
                            <span class="checkmark"></span>
                            Max: <input type="number" id="maxThresholdValue" value="90" onchange="updatePreviewChart()">% 표시
                            <span class="threshold-description">빨간색 점선으로 표시됩니다.</span>
                        </label>
                    </div>
                    
                    <div class="threshold-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showAverageLine" checked onchange="updatePreviewChart()">
                            <span class="checkmark"></span>
                            평균선 표시
                            <span class="threshold-description">초록색 점선으로 표시됩니다.</span>
                        </label>
                    </div>
                    
                    <div class="threshold-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showMinThreshold" checked onchange="updatePreviewChart()">
                            <span class="checkmark"></span>
                            Min: <input type="number" id="minThresholdValue" value="10" onchange="updatePreviewChart()">% 표시
                            <span class="threshold-description">노란색 점선으로 표시됩니다.</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="settings-footer">
                <button class="btn btn-secondary" id="cancelButton" onclick="closeChartSettings()">취소</button>
                <button class="btn btn-primary" id="applyButton" onclick="applyChartSettings()">적용</button>
            </div>
        </div>
    </div>

    <!-- 서버별 설정 모달 -->
    <div class="server-settings-modal" id="serverSettingsModal">
        <div class="modal-content settings-modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="serverSettingsTitle">서버 설정</h3>
                <button class="modal-close" onclick="closeServerSettings()">&times;</button>
            </div>
            <div class="settings-content" id="serverSettingsContent">
                <!-- 동적으로 생성됩니다 -->
            </div>
        </div>
    </div>

    <!-- 임계치 설정 모달 -->
    <div id="thresholdSettingsModal" class="modal">
        <div class="modal-content threshold-modal">
            <div class="modal-header">
                <h3>임계치 설정</h3>
                <button class="close-btn" onclick="closeThresholdSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p class="modal-description">체크 해제 시 임계치 선이 숨겨집니다.</p>
                <div class="threshold-settings">
                    <div class="threshold-item">
                        <div class="threshold-header">
                            <input type="checkbox" id="maxThresholdEnabled" checked>
                            <label for="maxThresholdEnabled">Max :</label>
                            <input type="number" id="maxThresholdValue" value="90" min="0" max="100">
                            <span class="unit">%</span>
                        </div>
                        <p class="threshold-description">빨간색 점선으로 표시됩니다</p>
                    </div>
                    <div class="threshold-item">
                        <div class="threshold-header">
                            <input type="checkbox" id="minThresholdEnabled" checked>
                            <label for="minThresholdEnabled">Min :</label>
                            <input type="number" id="minThresholdValue" value="10" min="0" max="100">
                            <span class="unit">%</span>
                        </div>
                        <p class="threshold-description">노란색 점선으로 표시됩니다</p>
                    </div>
                    <div class="threshold-item">
                        <div class="threshold-header">
                            <input type="checkbox" id="avgThresholdEnabled" checked>
                            <label for="avgThresholdEnabled">평균선</label>
                        </div>
                        <p class="threshold-description">초록색 점선으로 표시됩니다</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeThresholdSettingsModal()">취소</button>
                <button class="btn btn-primary" onclick="saveThresholdSettings()">저장</button>
            </div>
        </div>
    </div>

    <!-- 조회설정 모달 -->
    <div id="querySettingsModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h3>조회 설정</h3>
                <button class="close-btn" onclick="closeQuerySettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="accordion">
                    <div class="accordion-item active">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <h4>조회 기간 설정</h4>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="query-period-settings">
                                <div class="time-range-section">
                                    <div class="time-range-header">
                                        <button class="realtime-btn" onclick="toggleRealtimeMode()">실시간</button>
                                        <div class="time-range-display" id="timeRangeDisplay">2025/09/10 16:37 ~ 2025/09/10 17:37</div>
                                    </div>
                                    <div class="duration-controls">
                                        <input type="number" id="durationValue" value="1" min="1" max="24" onchange="updateTimeRange()">
                                        <span>시간</span>
                                        <button class="nav-btn" onclick="navigateTimeRange(-1)">&lt;</button>
                                        <button class="nav-btn" onclick="navigateTimeRange(1)">&gt;</button>
                                    </div>
                                    <div class="custom-time-settings" id="customTimeSettings" style="display: none;">
                                        <div class="time-picker-section">
                                            <div class="time-picker-group">
                                                <label>시작 시간:</label>
                                                <div class="datetime-picker">
                                                    <div class="date-input-wrapper">
                                                        <input type="date" id="startDate" onchange="updateTimeRange()">
                                                        <i class="fas fa-calendar-alt input-icon"></i>
                                                    </div>
                                                    <div class="time-input-wrapper">
                                                        <input type="time" id="startTime" onchange="updateTimeRange()">
                                                        <i class="fas fa-clock input-icon"></i>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="time-picker-group">
                                                <label>종료 시간:</label>
                                                <div class="datetime-picker">
                                                    <div class="date-input-wrapper">
                                                        <input type="date" id="endDate" onchange="updateTimeRange()">
                                                        <i class="fas fa-calendar-alt input-icon"></i>
                                                    </div>
                                                    <div class="time-input-wrapper">
                                                        <input type="time" id="endTime" onchange="updateTimeRange()">
                                                        <i class="fas fa-clock input-icon"></i>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="data-interval-section">
                                        <label>데이터 간격:</label>
                                        <select class="data-interval">
                                            <option value="1">1분</option>
                                            <option value="5">5분</option>
                                            <option value="15">15분</option>
                                            <option value="30">30분</option>
                                            <option value="60">1시간</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <h4>Y축 범위 설정</h4>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="y-axis-settings">
                                <div class="radio-group">
                                    <input type="radio" id="fixedRange" name="yAxisRange" checked>
                                    <label for="fixedRange">고정범위</label>
                                    <input type="number" id="yAxisMin" value="0" placeholder="최소값">
                                    <input type="number" id="yAxisMax" value="100" placeholder="최대값">
                                </div>
                                <div class="radio-group">
                                    <input type="radio" id="autoRange" name="yAxisRange">
                                    <label for="autoRange">MAX 기준 자동 조정</label>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <h4>시계열 차트</h4>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="time-series-settings">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="timeSeriesEnabled" checked>
                                    <label for="timeSeriesEnabled">시계열 차트 활성화</label>
                                </div>
                                <div class="comparison-settings">
                                    <label>비교 기간</label>
                                    <select id="comparisonPeriod" onchange="toggleCustomPeriod()">
                                        <option value="1day">1일전</option>
                                        <option value="1week">1주전</option>
                                        <option value="1month">1개월전</option>
                                        <option value="custom">사용자 선택</option>
                                    </select>
                                </div>
                                <div class="custom-period-settings" id="customPeriodSettings" style="display: none;">
                                    <div class="time-range-section">
                                        <div class="time-range-header">
                                            <div class="time-range-display" id="customTimeRangeDisplay2">2025/09/10 16:37 ~ 2025/09/10 17:37</div>
                                        </div>
                                        <div class="custom-time-settings" id="customTimeSettings2">
                                            <div class="time-picker-section">
                                                <div class="time-picker-group">
                                                    <label>시작 시간:</label>
                                                    <div class="datetime-picker">
                                                        <div class="date-input-wrapper">
                                                            <input type="date" id="customStartDate" onchange="updateCustomTimeRange()">
                                                            <i class="fas fa-calendar-alt input-icon"></i>
                                                        </div>
                                                        <div class="time-input-wrapper">
                                                            <input type="time" id="customStartTime" onchange="updateCustomTimeRange()">
                                                            <i class="fas fa-clock input-icon"></i>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="time-picker-group">
                                                    <label>종료 시간:</label>
                                                    <div class="datetime-picker">
                                                        <div class="date-input-wrapper">
                                                            <input type="date" id="customEndDate" onchange="updateCustomTimeRange()">
                                                            <i class="fas fa-calendar-alt input-icon"></i>
                                                        </div>
                                                        <div class="time-input-wrapper">
                                                            <input type="time" id="customEndTime" onchange="updateCustomTimeRange()">
                                                            <i class="fas fa-clock input-icon"></i>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="color-settings">
                                    <label>비교차트 Color</label>
                                    <div class="color-picker">
                                        <div class="color-preview" style="background-color: #ff0000;"></div>
                                        <input type="color" id="comparisonColor" value="#ff0000">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeQuerySettingsModal()">취소</button>
                <button class="btn btn-primary" onclick="saveQuerySettings()">적용</button>
            </div>
        </div>
    </div>

    <!-- 상세보기 모달 -->
    <div id="detailViewModal" class="modal fullscreen-modal">
        <div class="modal-content fullscreen-content">
            <div class="modal-header">
                <h3 id="detailViewTitle">차트 상세보기</h3>
                <button class="close-btn" onclick="closeDetailViewModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="detail-chart-container">
                    <canvas id="detailChartCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- 범례/서버선택 모달 -->
    <div id="legendSettingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="legendModalTitle">서버 선택(범례)</h3>
                <button class="close-btn" onclick="closeLegendSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="legend-controls">
                    <div class="radio-group">
                        <input type="radio" id="legendApply" name="legendMode" checked>
                        <label for="legendApply">적용</label>
                    </div>
                    <div class="radio-group">
                        <input type="radio" id="legendDisable" name="legendMode">
                        <label for="legendDisable">미적용</label>
                    </div>
                </div>
                <div class="legend-server-controls">
                    <div class="legend-server-actions">
                        <button class="btn btn-secondary" onclick="selectAllLegendServers()">전체 선택</button>
                        <button class="btn btn-secondary" onclick="deselectAllLegendServers()">전체 해제</button>
                    </div>
                </div>
                <div class="server-selection-list" id="legendServerList">
                    <!-- 서버 리스트는 JavaScript로 동적 생성 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeLegendSettingsModal()">취소</button>
                <button class="btn btn-primary" onclick="saveLegendSettings()">확인</button>
            </div>
        </div>
    </div>

    <!-- 대시보드 관리 모달 -->
    <div class="dashboard-management-modal" id="dashboardManagementModal">
        <div class="modal-content dashboard-management-content">
            <div class="modal-header">
                <h3 class="modal-title">대시보드 관리</h3>
                <button class="modal-close" onclick="closeDashboardManagement()">&times;</button>
            </div>
            <div class="dashboard-management-body">
                <!-- 관리자 대시보드 섹션 -->
                <div class="dashboard-section">
                    <div class="dashboard-section-header">
                        <div class="dashboard-section-icon admin-icon">
                            <i class="fas fa-crown"></i>
                        </div>
                        <h4 class="dashboard-section-title">관리자 대시보드 (7개)</h4>
                        <button class="new-dashboard-btn" onclick="scrollToCreateForm()" title="새 대시보드 생성">
                            <i class="fas fa-plus"></i>
                            새 대시보드
                        </button>
                    </div>
                    <div class="dashboard-list" id="adminDashboardList">
                <!-- 동적으로 생성됩니다 -->
                    </div>
                </div>
                
                <!-- 개인 대시보드 섹션 -->
                <div class="dashboard-section">
                    <div class="dashboard-section-header">
                        <div class="dashboard-section-icon personal-icon">
                            <i class="fas fa-user"></i>
                        </div>
                        <h4 class="dashboard-section-title">개인 대시보드 (6개)</h4>
                    </div>
                    <div class="dashboard-list" id="personalDashboardList">
                        <!-- 동적으로 생성됩니다 -->
                    </div>
                </div>

                <!-- 액션 버튼들 -->
                <div class="dashboard-actions">
                    <div class="action-buttons-left">
                        <button class="action-btn export-btn" id="exportBtn" onclick="exportSelectedDashboards()" disabled>
                            <i class="fas fa-download"></i>
                            내보내기
                        </button>
                        <button class="action-btn import-btn" onclick="importDashboardData()">
                            <i class="fas fa-upload"></i>
                            가져오기
                        </button>
                    </div>
                    <div class="action-buttons-right">
                        <button class="action-btn delete-btn" id="bulkDeleteBtn" onclick="deleteSelectedDashboards()" disabled>
                            <i class="fas fa-trash"></i>
                            선택 삭제 (<span id="selectedCount">0</span>)
                        </button>
                    </div>
                    <input type="file" id="dashboardFileInput" accept=".json" style="display: none;" onchange="handleDashboardFileUpload(event)">
                </div>

                <!-- 새 대시보드 생성 섹션 -->
                <div class="create-dashboard-section">
                    <div class="create-dashboard-header" onclick="toggleCreateDashboard()">
                        <h4 class="create-dashboard-title">+ 새 대시보드 생성</h4>
                        <i class="fas fa-chevron-up" id="createDashboardToggle"></i>
                </div>
                    <div class="create-dashboard-content" id="createDashboardContent">
                        <div class="form-group">
                            <label for="newDashboardName">대시보드 이름*</label>
                            <input type="text" id="newDashboardName" class="form-input" placeholder="대시보드 이름을 적어주세요" maxlength="50">
            </div>
                        <div class="form-group">
                            <label for="newDashboardDesc">설명(선택사항)</label>
                            <textarea id="newDashboardDesc" class="form-textarea" placeholder="대시보드에 대한 설명을 입력해 주세요" rows="3" maxlength="200"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="newDashboardType">대시보드 유형*</label>
                            <select id="newDashboardType" class="form-select">
                                <option value="admin">관리자 대시보드</option>
                                <option value="personal">개인 대시보드</option>
                            </select>
                        </div>
                        <div class="create-dashboard-buttons">
                            <button class="btn btn-primary" onclick="createNewDashboard()">생성하기</button>
                            <button class="btn btn-secondary" onclick="resetCreateDashboard()">초기화</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 대시보드 수정 모달 -->
    <div class="edit-dashboard-modal" id="editDashboardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">대시보드 수정</h3>
                <button class="modal-close" onclick="closeEditDashboard()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editDashboardName">대시보드 이름*</label>
                    <input type="text" id="editDashboardName" class="form-input" placeholder="대시보드 이름을 적어주세요" maxlength="50">
                </div>
                <div class="form-group">
                    <label for="editDashboardDesc">설명(선택사항)</label>
                    <textarea id="editDashboardDesc" class="form-textarea" placeholder="대시보드에 대한 설명을 입력해 주세요" rows="3" maxlength="200"></textarea>
                </div>
                <div class="form-group">
                    <label for="editDashboardType">대시보드 유형*</label>
                    <select id="editDashboardType" class="form-select">
                        <option value="admin">관리자 대시보드</option>
                        <option value="personal">개인 대시보드</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeEditDashboard()">취소</button>
                <button class="btn btn-primary" onclick="confirmEditDashboard()">수정완료</button>
            </div>
        </div>
    </div>

    <!-- 대시보드 삭제 확인 모달 -->
    <div class="delete-confirm-modal" id="deleteConfirmModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">대시보드 삭제 확인</h3>
                <button class="modal-close" onclick="closeDeleteConfirm()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="delete-warning">
                    <i class="fas fa-exclamation-triangle"></i>
                    <p>정말로 이 대시보드를 삭제하시겠습니까?</p>
                    <p class="delete-dashboard-name" id="deleteDashboardName"></p>
                    <p class="delete-warning-text">삭제된 대시보드는 복구할 수 없습니다.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeDeleteConfirm()">취소</button>
                <button class="btn btn-danger" onclick="confirmDeleteDashboard()">삭제</button>
            </div>
        </div>
    </div>

    <!-- 새 대시보드 생성 모달 -->
    <div class="create-dashboard-modal" id="createDashboardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">새 대시보드 생성</h3>
                <button class="modal-close" onclick="closeCreateDashboard()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="newDashboardName">대시보드 이름 *</label>
                    <input type="text" id="newDashboardName" class="form-input" placeholder="새 대시보드" maxlength="50">
                </div>
                <div class="form-group">
                    <label for="newDashboardDesc">설명 (선택사항)</label>
                    <textarea id="newDashboardDesc" class="form-textarea" placeholder="대시보드에 대한 설명을 입력하세요" rows="3" maxlength="200"></textarea>
                </div>
                <div class="form-group">
                    <label for="newDashboardType">대시보드 유형</label>
                    <select id="newDashboardType" class="form-select">
                        <option value="personal">개인 대시보드</option>
                        <option value="admin">관리자 대시보드</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCreateDashboard()">취소</button>
                <button class="btn btn-primary" onclick="confirmCreateDashboard()">생성</button>
            </div>
        </div>
    </div>

    <!-- 임계치 설정 패널 -->
    <div class="threshold-panel" id="thresholdPanel">
        <div class="threshold-header">
            <span id="thresholdTitle">임계치 설정</span>
            <button onclick="closeThresholdPanel()" style="float: right; background: none; border: none; cursor: pointer;">&times;</button>
        </div>
        <div class="threshold-content" id="thresholdContent">
            <!-- 동적으로 생성됩니다 -->
        </div>
    </div>

    <!-- 내보내기 모달 -->
    <div class="export-modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">
                    <i class="fas fa-download"></i>
                    대시보드 내보내기
                </h3>
                <button class="modal-close" onclick="closeExportModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="export-info">
                    <p>현재 대시보드 설정을 JSON 파일로 내보냅니다.</p>
                    <div class="export-details">
                        <div class="detail-item">
                            <span class="detail-label">대시보드명:</span>
                            <span class="detail-value" id="exportDashboardName">AMP 모니터링 대시보드</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">차트 수:</span>
                            <span class="detail-value" id="exportChartCount">0개</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">내보내기 일시:</span>
                            <span class="detail-value" id="exportDateTime">-</span>
                        </div>
                    </div>
                </div>
                <div class="export-options">
                    <label class="checkbox-label">
                        <input type="checkbox" id="includeSettings" checked>
                        <span class="checkmark"></span>
                        설정 정보 포함
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="includeLayout" checked>
                        <span class="checkmark"></span>
                        레이아웃 정보 포함
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="includeData" checked>
                        <span class="checkmark"></span>
                        차트 데이터 포함
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeExportModal()">취소</button>
                <button class="btn-primary" onclick="executeExport()">
                    <i class="fas fa-download"></i>
                    내보내기
                </button>
            </div>
        </div>
    </div>

    <!-- 가져오기 모달 -->
    <div class="import-modal" id="importModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">
                    <i class="fas fa-upload"></i>
                    대시보드 가져오기
                </h3>
                <button class="modal-close" onclick="closeImportModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- 가져오기 대상 선택 (관리자만 표시) -->
                <div class="import-destination-section" id="importDestinationSection">
                    <div class="section-title">
                        <i class="fas fa-folder-open"></i>
                        <span>가져오기 대상 선택</span>
                    </div>
                    <div class="destination-options">
                        <label class="destination-option">
                            <input type="radio" name="importDestination" value="admin" checked>
                            <div class="option-content">
                                <div class="option-icon admin-icon">
                                    <i class="fas fa-crown"></i>
                                </div>
                                <div class="option-text">
                                    <div class="option-title">관리자 대시보드</div>
                                    <div class="option-desc">전체 사용자가 접근 가능한 대시보드</div>
                                </div>
                            </div>
                        </label>
                        <label class="destination-option">
                            <input type="radio" name="importDestination" value="personal">
                            <div class="option-content">
                                <div class="option-icon personal-icon">
                                    <i class="fas fa-user"></i>
                                </div>
                                <div class="option-text">
                                    <div class="option-title">개인 대시보드</div>
                                    <div class="option-desc">개인 전용 대시보드</div>
                                </div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <div class="import-upload-area" id="importUploadArea" onclick="triggerFileInput()">
                    <div class="upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <div class="upload-text">
                        <p class="upload-title">JSON 파일을 선택하거나 여기에 드래그하세요</p>
                        <p class="upload-subtitle">지원 형식: .json</p>
                    </div>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                </div>
                <div class="import-preview" id="importPreview" style="display: none;">
                    <div class="preview-header">
                        <i class="fas fa-file-code"></i>
                        <span>파일 미리보기</span>
                    </div>
                    <div class="preview-content" id="previewContent">
                        <!-- 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeImportModal()">취소</button>
                <button class="btn-primary" id="importExecuteBtn" onclick="executeImport()" disabled>
                    <i class="fas fa-upload"></i>
                    가져오기
                </button>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let currentMode = 'view';
        let currentDashboard = 'default';
        let dataMode = 'realtime';
        let globalTimeRange = '1h';
        let xAxisRangeMode = 'global'; // 'global' 또는 'individual'
        let individualXAxisRanges = {}; // 차트별 개별 x축 범위 저장
        let charts = {};
        let chartConfigs = {};

        // 상세보기 모달 열기 (전역 함수)
        function openDetailView(chartId) {
            console.log('openDetailView 호출됨, chartId:', chartId);
            
            const modal = document.getElementById('detailViewModal');
            const title = document.getElementById('detailViewTitle');
            const canvas = document.getElementById('detailChartCanvas');
            
            if (!modal) {
                console.error('detailViewModal을 찾을 수 없습니다');
                return;
            }
            
            title.textContent = `${chartId} 차트 상세보기`;
            
            // 기존 차트가 있다면 제거
            if (window.detailChart) {
                window.detailChart.destroy();
            }
            
            // 원본 차트 데이터 가져오기
            const originalChart = window.charts[chartId];
            console.log('원본 차트:', originalChart);
            
            if (!originalChart) {
                console.error('차트를 찾을 수 없습니다:', chartId);
                return;
            }
            
            // 모달 표시
            modal.style.display = 'block';
            
            // 차트 생성 (모달이 표시된 후)
            setTimeout(() => {
                const ctx = canvas.getContext('2d');
                const chartConfig = {
                    type: originalChart.config.type,
                    data: {
                        labels: originalChart.data.labels,
                        datasets: originalChart.data.datasets.map(dataset => ({
                            ...dataset,
                            borderWidth: 3,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }))
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 20,
                                    font: {
                                        size: 14
                                    }
                                }
                            },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#fff',
                                bodyColor: '#fff',
                                borderColor: '#fff',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: '시간',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: originalChart.options.scales?.y?.title?.text || '값',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        animation: {
                            duration: 1000,
                            easing: 'easeInOutQuart'
                        }
                    }
                };
                
                // 상세보기 차트 생성
                window.detailChart = new Chart(ctx, chartConfig);
                console.log('상세보기 차트 생성 완료');
            }, 100);
        }

        // 전역에서 함수 접근 가능하도록 설정
        window.openDetailView = openDetailView;
        let thresholds = {};
        let cardVisibility = {};
        
        // 대시보드 설정 저장소
        let dashboardConfigs = {
            default: {
                name: '기본 대시보드',
                type: 'default',
                charts: ['stt-cpu', 'stt-memory', 'tts-cpu', 'tts-memory', 'sv-cpu', 'sv-memory'],
                layout: 'grid',
                description: '기본 모니터링 대시보드'
            },
            admin1: {
                name: '관리자 대시보드 1',
                type: 'admin',
                charts: ['stt-cpu', 'stt-memory', 'stt-disk', 'tts-cpu', 'tts-memory', 'tts-disk', 'sv-cpu', 'sv-memory', 'sv-disk'],
                layout: 'grid',
                description: '시스템 전체 현황 모니터링'
            },
            admin2: {
                name: '관리자 대시보드 2',
                type: 'admin',
                charts: ['stt-requests', 'stt-usage', 'tts-requests', 'tts-cache-hit', 'sv-auth'],
                layout: 'grid',
                description: '서비스 성능 중심 모니터링'
            },
            admin3: {
                name: '관리자 대시보드 3',
                type: 'admin',
                charts: ['stt-epd', 'tts-synthesis', 'sv-auth', 'stt-failures', 'tts-failures'],
                layout: 'grid',
                description: '상세 분석 모니터링'
            },
            personal1: {
                name: '개인 대시보드 1',
                type: 'personal',
                charts: ['stt-cpu', 'stt-memory', 'stt-requests'],
                layout: 'grid',
                description: '개인 맞춤 모니터링 1'
            },
            personal2: {
                name: '개인 대시보드 2',
                type: 'personal',
                charts: ['tts-cpu', 'tts-memory', 'tts-requests', 'tts-tps'],
                layout: 'grid',
                description: '개인 맞춤 모니터링 2'
            },
            personal3: {
                name: '개인 대시보드 3',
                type: 'personal',
                charts: ['stt-usage', 'tts-cache-hit', 'sv-auth'],
                layout: 'grid',
                description: '개인 맞춤 모니터링 3'
            }
        };

        // 엔진별 차트 정의 (엔진별 HW 리소스 + 서비스별 메트릭)
        const engineCharts = {
            stt: [
                // STT 엔진 하드웨어 리소스
                { id: 'stt-cpu', name: 'STT CPU 사용률', type: 'stt', icon: 'fas fa-microchip', unit: '%', max: 100, 
                  metrics: ['usage', 'max', 'avg'], category: 'hw' },
                { id: 'stt-memory', name: 'STT 메모리 사용률', type: 'stt', icon: 'fas fa-memory', unit: '%', max: 100,
                  metrics: ['usage', 'max', 'available'], category: 'hw' },
                { id: 'stt-disk', name: 'STT 디스크 사용률', type: 'stt', icon: 'fas fa-hdd', unit: '%', max: 100,
                  metrics: ['usage', 'read', 'write'], category: 'hw' },
                // STT 서비스 메트릭
                { id: 'stt-requests', name: 'STT 요청 건수', type: 'stt', icon: 'fas fa-microphone', unit: '건', max: 1000,
                  metrics: ['requests', 'success', 'failed'], category: 'service' },
                { id: 'stt-failures', name: 'STT 실패 건수', type: 'stt', icon: 'fas fa-exclamation-triangle', unit: '건', max: 100,
                  metrics: ['failed', 'errorRate'], category: 'service' },
                { id: 'stt-realtime-calls', name: 'STT 실시간 콜정보', type: 'stt', icon: 'fas fa-phone', unit: '건', max: 50,
                  metrics: ['activeCalls', 'waitingCalls'], category: 'service' },
                { id: 'stt-usage', name: 'STT 사용량 통계', type: 'stt', icon: 'fas fa-chart-bar', unit: '%', max: 100,
                  metrics: ['usage', 'modelA', 'modelB'], category: 'service' },
                { id: 'stt-epd', name: 'STT EPD 시간 통계', type: 'stt', icon: 'fas fa-clock', unit: 'ms', max: 5000,
                  metrics: ['avgEpd', 'maxEpd', 'minEpd'], category: 'service' },
                { id: 'stt-latency', name: 'STT 응답 지연시간', type: 'stt', icon: 'fas fa-stopwatch', unit: 'ms', max: 2000,
                  metrics: ['latency', 'avgLatency', 'maxLatency'], category: 'service' },
                { id: 'stt-throughput', name: 'STT 처리량', type: 'stt', icon: 'fas fa-tachometer-alt', unit: 'req/s', max: 1000,
                  metrics: ['throughput', 'maxThroughput', 'avgThroughput'], category: 'service' },
                { id: 'stt-accuracy', name: 'STT 정확도', type: 'stt', icon: 'fas fa-bullseye', unit: '%', max: 100,
                  metrics: ['accuracy', 'wordAccuracy', 'sentenceAccuracy'], category: 'service' },
                { id: 'stt-concurrent', name: 'STT 동시 처리', type: 'stt', icon: 'fas fa-users', unit: '명', max: 100,
                  metrics: ['concurrent', 'maxConcurrent', 'avgConcurrent'], category: 'service' },
                { id: 'stt-queue', name: 'STT 대기열', type: 'stt', icon: 'fas fa-list-ol', unit: '건', max: 500,
                  metrics: ['queueLength', 'avgQueue', 'maxQueue'], category: 'service' },
                { id: 'stt-error', name: 'STT 오류율', type: 'stt', icon: 'fas fa-exclamation-circle', unit: '%', max: 10,
                  metrics: ['errorRate', 'timeoutRate', 'rejectRate'], category: 'service' },
                { id: 'stt-resource', name: 'STT 리소스 사용률', type: 'stt', icon: 'fas fa-cogs', unit: '%', max: 100,
                  metrics: ['resourceUsage', 'cpuUsage', 'memoryUsage'], category: 'service' },
                { id: 'stt-quality', name: 'STT 품질 점수', type: 'stt', icon: 'fas fa-star', unit: '점', max: 10,
                  metrics: ['qualityScore', 'avgQuality', 'minQuality'], category: 'service' },
                { id: 'stt-session', name: 'STT 세션 관리', type: 'stt', icon: 'fas fa-link', unit: '개', max: 1000,
                  metrics: ['activeSessions', 'maxSessions', 'avgSessions'], category: 'service' }
            ],
            tts: [
                // TTS 엔진 하드웨어 리소스
                { id: 'tts-cpu', name: 'TTS CPU 사용률', type: 'tts', icon: 'fas fa-microchip', unit: '%', max: 100, 
                  metrics: ['usage', 'max', 'avg'], category: 'hw' },
                { id: 'tts-memory', name: 'TTS 메모리 사용률', type: 'tts', icon: 'fas fa-memory', unit: '%', max: 100,
                  metrics: ['usage', 'max', 'available'], category: 'hw' },
                { id: 'tts-disk', name: 'TTS 디스크 사용률', type: 'tts', icon: 'fas fa-hdd', unit: '%', max: 100,
                  metrics: ['usage', 'read', 'write'], category: 'hw' },
                // TTS 서비스 메트릭
                { id: 'tts-requests', name: 'TTS 요청 건수', type: 'tts', icon: 'fas fa-volume-up', unit: '건', max: 1000,
                  metrics: ['requests', 'success', 'failed'], category: 'service' },
                { id: 'tts-failures', name: 'TTS 실패 건수', type: 'tts', icon: 'fas fa-exclamation-triangle', unit: '건', max: 100,
                  metrics: ['failed', 'errorRate'], category: 'service' },
                { id: 'tts-tps', name: 'TTS TPS 정보', type: 'tts', icon: 'fas fa-tachometer-alt', unit: 'TPS', max: 100,
                  metrics: ['tps', 'maxTps', 'avgTps'], category: 'service' },
                { id: 'tts-usage', name: 'TTS 사용량 통계', type: 'tts', icon: 'fas fa-chart-bar', unit: '%', max: 100,
                  metrics: ['usage', 'voiceA', 'voiceB'], category: 'service' },
                { id: 'tts-cache-hit', name: 'TTS 캐시 히트율', type: 'tts', icon: 'fas fa-database', unit: '%', max: 100,
                  metrics: ['cacheHit', 'cacheMiss'], category: 'service' },
                { id: 'tts-synthesis', name: 'TTS 음성 합성율', type: 'tts', icon: 'fas fa-music', unit: '%', max: 100,
                  metrics: ['synthesis', 'efficiency'], category: 'service' }
            ],
            sv: [
                // SV 엔진 하드웨어 리소스
                { id: 'sv-cpu', name: 'SV CPU 사용률', type: 'sv', icon: 'fas fa-microchip', unit: '%', max: 100, 
                  metrics: ['usage', 'max', 'avg'], category: 'hw' },
                { id: 'sv-memory', name: 'SV 메모리 사용률', type: 'sv', icon: 'fas fa-memory', unit: '%', max: 100,
                  metrics: ['usage', 'max', 'available'], category: 'hw' },
                { id: 'sv-disk', name: 'SV 디스크 사용률', type: 'sv', icon: 'fas fa-hdd', unit: '%', max: 100,
                  metrics: ['usage', 'read', 'write'], category: 'hw' },
                // SV 서비스 메트릭
                { id: 'sv-auth', name: 'SV 인증률', type: 'sv', icon: 'fas fa-shield-alt', unit: '%', max: 100,
                  metrics: ['authRate', 'success', 'failed'], category: 'service' }
            ]
        };

        // 모든 차트 통합
        const allCharts = {
            ...engineCharts.stt,
            ...engineCharts.tts,
            ...engineCharts.sv
        };

        // 초기화
        function initializeDashboard() {
            updateCurrentTime();
            setInterval(updateCurrentTime, 1000);
            
            // 초기 표시 설정
            initializeCardVisibility();
            createOptionsPanel();
            renderCharts();
            
            // 서버 그룹 렌더링
            renderServerGroups();
            
            // 초기 서버목록 카드 표시 여부 설정
            updateServerPanelVisibility();
            
            // 30초마다 실시간 업데이트
            setInterval(() => {
                if (dataMode === 'realtime') {
                    updateAllCharts();
                }
            }, 30000);
        }

        // 카드 표시 상태 초기화
        function initializeCardVisibility() {
            console.log('🔄 카드 표시 상태 초기화 시작');
            console.log('📋 엔진 차트 키:', Object.keys(engineCharts));
            
            Object.keys(engineCharts).forEach(engine => {
                console.log(`🔧 ${engine} 엔진 초기화:`, engineCharts[engine].length, '개 차트');
                cardVisibility[engine] = {};
                engineCharts[engine].forEach((chart, index) => {
                    // 수정 모드 테스트를 위해 첫 번째 차트만 표시
                    if (index === 0) {
                        cardVisibility[engine][chart.id] = true;
                        console.log(`  ✅ ${chart.id}: 표시 설정 (테스트용)`);
                    } else {
                        cardVisibility[engine][chart.id] = false;
                        console.log(`  ❌ ${chart.id}: 숨김 설정`);
                    }
                });
            });
            
            console.log('📊 최종 cardVisibility:', cardVisibility);
            console.log('✅ 카드 표시 상태 초기화 완료 (테스트용)');
        }

        // 옵션 패널 생성
        function createOptionsPanel() {
            const grid = document.getElementById('optionsGrid');
            grid.innerHTML = '';

            Object.keys(engineCharts).forEach(engine => {
                const group = document.createElement('div');
                group.className = `option-group ${engine}`;
                
                group.innerHTML = `
                    <div class="option-label" onclick="toggleGroupSelection('${engine}')">${getEngineDisplayName(engine)}:</div>
                    <div class="checkbox-group">
                        ${engineCharts[engine].map(chart => `
                            <div class="checkbox-item">
                                <input type="checkbox" id="option-${chart.id}" 
                                       ${cardVisibility[engine][chart.id] ? 'checked' : ''}
                                       onchange="toggleCardVisibility('${engine}', '${chart.id}')">
                                <label for="option-${chart.id}">${chart.name}</label>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                grid.appendChild(group);
            });
        }

        // 그룹 전체 선택/해제
        function toggleGroupSelection(engine) {
            if (!engineCharts[engine]) return;
            
            // 현재 그룹의 모든 항목이 선택되어 있는지 확인
            const allSelected = engineCharts[engine].every(chart => 
                cardVisibility[engine][chart.id]
            );
            
            // 전체 선택되어 있으면 모두 해제, 그렇지 않으면 모두 선택
            const newState = !allSelected;
            
            engineCharts[engine].forEach(chart => {
                cardVisibility[engine][chart.id] = newState;
                
                // 체크박스 상태 업데이트
                const checkbox = document.getElementById(`option-${chart.id}`);
                if (checkbox) {
                    checkbox.checked = newState;
                }
                
                // 차트 표시/숨김 업데이트
                const chartElement = document.getElementById(`chart-${chart.id}`);
                if (chartElement) {
                    chartElement.style.display = newState ? 'block' : 'none';
                }
            });
            
            // 그룹 라벨에 시각적 피드백 추가
            const label = event.target;
            label.style.transform = 'scale(0.95)';
            setTimeout(() => {
                label.style.transform = 'scale(1)';
            }, 150);
        }

        // 엔진 표시명 가져오기
        function getEngineDisplayName(engine) {
            const names = {
                common: '공통',
                stt: 'STT',
                tts: 'TTS',
                sv: 'SV'
            };
            return names[engine] || engine.toUpperCase();
        }

        // 카드 표시/숨김 토글
        function toggleCardVisibility(engine, chartId) {
            cardVisibility[engine][chartId] = !cardVisibility[engine][chartId];
            renderCharts();
            
            // 서버목록 카드 표시 여부 업데이트
            updateServerPanelVisibility();
        }

        // 리사이즈 핸들 설정
        function setupResizeListeners() {
            const cards = document.querySelectorAll('.chart-card');
            cards.forEach(card => {
                updateResizeHandles(card);
            });
        }

        // 리사이즈 핸들 업데이트
        function updateResizeHandles(card) {
            // 기존 핸들 제거
            const existingHandles = card.querySelector('.resize-handles');
            if (existingHandles) {
                existingHandles.remove();
            }

            // 수정 모드에서만 핸들 추가
            if (currentMode === 'edit') {
                const handlesContainer = document.createElement('div');
                handlesContainer.className = 'resize-handles';
                handlesContainer.innerHTML = `
                    <div class="resize-handle resize-nw" data-direction="nw"></div>
                    <div class="resize-handle resize-ne" data-direction="ne"></div>
                    <div class="resize-handle resize-sw" data-direction="sw"></div>
                    <div class="resize-handle resize-se" data-direction="se"></div>
                    <div class="resize-handle resize-n" data-direction="n"></div>
                    <div class="resize-handle resize-s" data-direction="s"></div>
                    <div class="resize-handle resize-w" data-direction="w"></div>
                    <div class="resize-handle resize-e" data-direction="e"></div>
                `;
                card.appendChild(handlesContainer);

                // 각 핸들에 이벤트 리스너 추가
                const handles = handlesContainer.querySelectorAll('.resize-handle');
                handles.forEach(handle => {
                    handle.addEventListener('mousedown', handleResizeStart);
                });
            }
        }

        // 리사이즈 시작
        function handleResizeStart(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isResizing = true;
            resizeElement = e.target.closest('.chart-card');
            resizeDirection = e.target.dataset.direction;
            
            startX = e.clientX;
            startY = e.clientY;
            
            const rect = resizeElement.getBoundingClientRect();
            startWidth = rect.width;
            startHeight = rect.height;
            
            resizeElement.style.position = 'relative';
            
            document.addEventListener('mousemove', handleResizeMove);
            document.addEventListener('mouseup', handleResizeEnd);
            
            document.body.style.cursor = e.target.style.cursor;
        }

        // 리사이즈 중
        function handleResizeMove(e) {
            if (!isResizing || !resizeElement) return;
            
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            let newWidth = startWidth;
            let newHeight = startHeight;
            
            // 방향에 따른 크기 계산
            if (resizeDirection.includes('e')) {
                newWidth = startWidth + deltaX;
            }
            if (resizeDirection.includes('w')) {
                newWidth = startWidth - deltaX;
            }
            if (resizeDirection.includes('s')) {
                newHeight = startHeight + deltaY;
            }
            if (resizeDirection.includes('n')) {
                newHeight = startHeight - deltaY;
            }
            
            // 최소/최대 크기 제한
            newWidth = Math.max(280, Math.min(800, newWidth));
            newHeight = Math.max(200, Math.min(600, newHeight));
            
            resizeElement.style.width = newWidth + 'px';
            resizeElement.style.height = newHeight + 'px';
            
            // 차트 리사이즈 (디바운싱)
            clearTimeout(resizeElement.resizeTimeout);
            resizeElement.resizeTimeout = setTimeout(() => {
                const chartId = resizeElement.id.replace('card-', '');
                const chart = charts[chartId];
                if (chart) {
                    const canvas = document.getElementById(`chart-${chartId}`);
                    if (canvas) {
                        const container = canvas.parentElement;
                        const containerRect = container.getBoundingClientRect();
                        
                        // 캔버스 크기 직접 설정
                        canvas.style.width = containerRect.width + 'px';
                        canvas.style.height = containerRect.height + 'px';
                        canvas.width = containerRect.width;
                        canvas.height = containerRect.height;
                        
                        // Chart.js 리사이즈
                        chart.resize();
                        chart.update('none');
                    }
                }
            }, 16); // 60fps로 제한
        }

        // 리사이즈 종료
        function handleResizeEnd(e) {
            if (!isResizing) return;
            
            isResizing = false;
            document.body.style.cursor = '';
            
            document.removeEventListener('mousemove', handleResizeMove);
            document.removeEventListener('mouseup', handleResizeEnd);
            
            // 최종 차트 업데이트
            if (resizeElement) {
                const chartId = resizeElement.id.replace('card-', '');
                const chart = charts[chartId];
                if (chart) {
                    setTimeout(() => {
                        const canvas = document.getElementById(`chart-${chartId}`);
                        if (canvas) {
                            const container = canvas.parentElement;
                            const containerRect = container.getBoundingClientRect();
                            
                            // 캔버스 크기 최종 설정
                            canvas.style.width = containerRect.width + 'px';
                            canvas.style.height = containerRect.height + 'px';
                            canvas.width = containerRect.width;
                            canvas.height = containerRect.height;
                            
                            // Chart.js 최종 리사이즈
                            chart.resize();
                            chart.update('none');
                        }
                    }, 10);
                }
            }
            
            resizeElement = null;
            resizeDirection = null;
        }

        // 모드 전환
        function switchMode(mode) {
            currentMode = mode;
            const viewBtn = document.getElementById('viewModeBtn');
            const editBtn = document.getElementById('editModeBtn');
            const container = document.getElementById('mainContainer');
            
            if (mode === 'edit') {
                viewBtn.classList.remove('active');
                editBtn.classList.add('active');
                container.classList.add('edit-mode');
                container.classList.remove('view-mode');
                enableDragAndDrop();
                setupResizeListeners();
            } else {
                viewBtn.classList.add('active');
                editBtn.classList.remove('active');
                container.classList.remove('edit-mode');
                container.classList.add('view-mode');
                disableDragAndDrop();
                setupResizeListeners();
            }
            
            // 서버목록 카드 표시 여부 업데이트
            updateServerPanelVisibility();
        }

        // 대시보드 모드 설정
        function setViewMode() {
            document.getElementById('viewModeBtn').classList.add('active');
            document.getElementById('editModeBtn').classList.remove('active');
            switchMode('view');
        }

        function setEditMode() {
            document.getElementById('viewModeBtn').classList.remove('active');
            document.getElementById('editModeBtn').classList.add('active');
            switchMode('edit');
        }

        // 대시보드 샘플 데이터
        const dashboardSamples = {
            public: {
                admin1: {
                    name: "관리자1",
                    description: "시스템 전체 모니터링",
                    charts: ["cpu", "memory", "disk", "network", "stt-requests", "tts-requests"]
                },
                admin2: {
                    name: "관리자2", 
                    description: "서비스별 상세 모니터링",
                    charts: ["stt-requests", "stt-failures", "tts-requests", "tts-failures", "sv-auth"]
                },
                admin3: {
                    name: "관리자3",
                    description: "성능 분석 대시보드", 
                    charts: ["cpu", "memory", "stt-requests", "tts-requests", "sv-auth"]
                }
            },
            personal: {
                personal1: {
                    name: "1.대시보드",
                    description: "기본 모니터링",
                    charts: ["cpu", "memory", "stt-requests"]
                },
                personal2: {
                    name: "2.대시보드", 
                    description: "STT/TTS 전용",
                    charts: ["stt-requests", "stt-failures", "tts-requests", "tts-failures"]
                },
                personal3: {
                    name: "3.대시보드",
                    description: "전체 서비스 모니터링",
                    charts: ["cpu", "memory", "disk", "stt-requests", "stt-failures", "tts-requests", "tts-failures", "sv-auth"]
                }
            }
        };

        // 대시보드 유형 설정
        function setDashboardType(type) {
            const publicBtn = document.getElementById('publicTypeBtn');
            const personalBtn = document.getElementById('personalTypeBtn');
            const dropdown = document.getElementById('dashboardSelect');
            
            if (type === 'public') {
                publicBtn.classList.add('active');
                personalBtn.classList.remove('active');
                dropdown.innerHTML = `
                    <option value="admin1">관리자1</option>
                    <option value="admin2">관리자2</option>
                    <option value="admin3">관리자3</option>
                `;
            } else {
                publicBtn.classList.remove('active');
                personalBtn.classList.add('active');
                dropdown.innerHTML = `
                    <option value="personal1">1.대시보드</option>
                    <option value="personal2">2.대시보드</option>
                    <option value="personal3">3.대시보드</option>
                `;
            }
        }

        // 대시보드 선택
        function selectDashboard(dashboardId) {
            currentDashboard = dashboardId;
            
            // 대시보드 설정 로드
            loadDashboardConfig(dashboardId);
            
            // 선택된 대시보드의 차트만 표시
            updateDashboardCharts(dashboardId);
            
            // 차트 렌더링
            renderCharts();
        }

        // 대시보드별 차트 업데이트
        function updateDashboardCharts(dashboardId) {
            // 현재 유형 확인
            const isPublic = dashboardId.startsWith('admin');
            const type = isPublic ? 'public' : 'personal';
            const dashboard = dashboardSamples[type][dashboardId];
            
            if (!dashboard) return;
            
            // 모든 차트 숨기기
            Object.keys(cardVisibility).forEach(engine => {
                Object.keys(cardVisibility[engine]).forEach(chartId => {
                    cardVisibility[engine][chartId] = false;
                });
            });
            
            // 선택된 대시보드의 차트만 표시
            dashboard.charts.forEach(chartId => {
                // 차트 ID를 엔진과 차트로 분리
                if (chartId.includes('-')) {
                    const [engine, chart] = chartId.split('-');
                    if (cardVisibility[engine] && cardVisibility[engine][chart]) {
                        cardVisibility[engine][chart] = true;
                    }
                } else {
                    // 공통 하드웨어 리소스
                    if (cardVisibility.common && cardVisibility.common[chartId]) {
                        cardVisibility.common[chartId] = true;
                    }
                }
            });
            
            // 옵션 패널 업데이트
            createOptionsPanel();
            
            // 서버목록 카드 표시 여부 업데이트
            updateServerPanelVisibility();
        }

        // 서버목록 카드 표시 여부 업데이트
        function updateServerPanelVisibility() {
            const serverPanel = document.getElementById('serverSelectionPanel');
            if (!serverPanel) return;
            
            // STT, TTS, SV 항목 중 하나라도 활성화되어 있는지 확인
            const hasServiceCharts = 
                (cardVisibility.stt && Object.values(cardVisibility.stt).some(visible => visible)) ||
                (cardVisibility.tts && Object.values(cardVisibility.tts).some(visible => visible)) ||
                (cardVisibility.sv && Object.values(cardVisibility.sv).some(visible => visible));
            
            if (hasServiceCharts) {
                serverPanel.classList.add('has-service-charts');
            } else {
                serverPanel.classList.remove('has-service-charts');
            }
        }

        // 대시보드 설정 로드
        function loadDashboardConfig(dashboardId) {
            const config = dashboardConfigs[dashboardId];
            if (!config) return;
            
            // 카드 표시 상태 초기화
            initializeCardVisibility();
            
            // 대시보드별 차트 설정 적용
            if (config.charts) {
                Object.keys(engineCharts).forEach(engine => {
                    engineCharts[engine].forEach(chart => {
                        cardVisibility[engine][chart.id] = config.charts.includes(chart.id);
                    });
                });
            }
            
            // 옵션 패널 업데이트
            createOptionsPanel();
            
            showNotification(`${config.name}이 로드되었습니다.`);
        }

        // 차트 렌더링
        function renderCharts() {
            console.log('🔄 차트 렌더링 시작');
            
            const grid = document.getElementById('chartsGrid');
            if (!grid) {
                console.error('❌ chartsGrid 요소를 찾을 수 없습니다');
                return;
            }
            
            grid.innerHTML = '';
            console.log('✅ 차트 그리드 초기화 완료');

            let chartsToShow = [];
            
            // 대시보드별 차트 표시
            Object.keys(engineCharts).forEach(engine => {
                console.log(`🔍 ${engine} 엔진 차트 확인:`, engineCharts[engine].length, '개');
                engineCharts[engine].forEach(chart => {
                    const isVisible = cardVisibility[engine] && cardVisibility[engine][chart.id];
                    console.log(`  - ${chart.id}: ${isVisible ? '표시' : '숨김'}`);
                    if (isVisible) {
                        chartsToShow.push(chart);
                    }
                });
            });

            console.log(`📊 표시할 차트 개수: ${chartsToShow.length}개`);
            console.log('📋 표시할 차트 목록:', chartsToShow.map(c => c.id));

            chartsToShow.forEach((chartConfig, index) => {
                console.log(`🎨 차트 카드 생성 중: ${chartConfig.id} (${index + 1}/${chartsToShow.length})`);
                const card = createChartCard(chartConfig);
                grid.appendChild(card);
                
                // 차트 초기화 - DOM이 완전히 렌더링된 후 실행
                setTimeout(() => {
                    console.log(`⚡ 차트 초기화: ${chartConfig.id}`);
                    initializeChart(chartConfig);
                }, 200);
            });
            
            console.log('✅ 차트 렌더링 완료');
        }

        // 차트 카드 생성
        function createChartCard(config) {
            const card = document.createElement('div');
            card.className = `chart-card ${config.type}`;
            card.id = `card-${config.id}`;
            card.draggable = currentMode === 'edit';
            
            
            card.innerHTML = `
                <div class="chart-header">
                    <div class="chart-title-section">
                        <div class="chart-title">
                            <div class="chart-icon ${config.type}">
                                <i class="${config.icon}"></i>
                            </div>
                            ${config.name}
                        </div>
                    </div>
                    <div class="chart-header-controls">
                        <button class="chart-action-btn period-query-btn" onclick="openPeriodQuery('${config.id}')" title="기간조회">
                            <i class="fas fa-clock"></i>
                        </button>
                        <button class="chart-action-btn chart-settings-btn" onclick="openChartSettings('${config.id}')" title="차트설정">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                        </div>
                </div>
                <div class="chart-container" id="chart-container-${config.id}">
                    <canvas id="chart-${config.id}"></canvas>
                </div>
                ${currentMode === 'edit' ? `
                    <div class="resize-handles">
                        <div class="resize-handle resize-nw" data-direction="nw"></div>
                        <div class="resize-handle resize-ne" data-direction="ne"></div>
                        <div class="resize-handle resize-sw" data-direction="sw"></div>
                        <div class="resize-handle resize-se" data-direction="se"></div>
                        <div class="resize-handle resize-n" data-direction="n"></div>
                        <div class="resize-handle resize-s" data-direction="s"></div>
                        <div class="resize-handle resize-w" data-direction="w"></div>
                        <div class="resize-handle resize-e" data-direction="e"></div>
                    </div>
                ` : ''}
            `;
            
            return card;
        }



        // 차트 초기화
        function initializeChart(config) {
            const ctx = document.getElementById(`chart-${config.id}`);
            if (!ctx) {
                console.error(`Chart canvas not found: chart-${config.id}`);
                return;
            }

            console.log(`Initializing chart: ${config.id}`);

            const timeLabels = generateTimeLabels();
            const datasets = generateChartDatasets(config, timeLabels);

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            titleColor: '#212529',
                            bodyColor: '#495057',
                            borderColor: '#ced4da',
                            borderWidth: 1,
                            cornerRadius: 6
                        },
                        maxValueDisplay: {
                            display: true,
                            color: '#ef4444',
                            fontSize: 12,
                            fontWeight: 'bold',
                            chartConfig: config
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: { minute: 'HH:mm' }
                            },
                            grid: { display: false },
                            ticks: { color: '#6c757d', font: { size: 10 } }
                        },
                        y: {
                            beginAtZero: true,
                            max: config.max,
                            grid: { display: false },
                            ticks: {
                                color: '#6c757d',
                                font: { size: 10 },
                                callback: function(value) {
                                    // 데이터 타입에 따라 단위 결정
                                    const unit = getChartUnit(config);
                                    return value + unit;
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });

            charts[config.id] = chart;
            chartConfigs[config.id] = config;
            
            // Chart 인스턴스를 canvas 요소에 저장
            ctx.chart = chart;
        }

        // 시간 라벨 생성
        function generateTimeLabels() {
            const labels = [];
            const now = new Date();
            const duration = getDurationInMinutes(globalTimeRange);
            const startTime = new Date(now.getTime() - duration * 60 * 1000);

            const interval = Math.max(1, Math.floor(duration / 60)); // 최대 60개 포인트
            
            for (let i = 0; i <= duration; i += interval) {
                const time = new Date(startTime.getTime() + i * 60 * 1000);
                labels.push(time);
            }
            
            return labels;
        }

        // 기간을 분 단위로 변환
        function getDurationInMinutes(range) {
            const durations = {
                '30m': 30,
                '1h': 60,
                '3h': 180,
                '6h': 360,
                '12h': 720,
                '24h': 1440
            };
            return durations[range] || 60;
        }

        // 메트릭 표시명 가져오기
        function getMetricDisplayName(metric) {
            const metricNames = {
                'usage': '사용률',
                'max': '최대값',
                'avg': '평균값',
                'available': '사용가능',
                'read': '읽기',
                'write': '쓰기',
                'requests': '요청',
                'success': '성공',
                'failed': '실패',
                'errorRate': '오류율',
                'tps': 'TPS',
                'maxTps': '최대 TPS',
                'avgTps': '평균 TPS',
                'modelA': '모델 A',
                'modelB': '모델 B',
                'voiceA': '음성 A',
                'voiceB': '음성 B',
                'cacheHit': '캐시 히트',
                'cacheMiss': '캐시 미스',
                'synthesis': '합성',
                'efficiency': '효율성',
                'authRate': '인증률',
                'activeCalls': '활성 통화',
                'waitingCalls': '대기 통화',
                'avgEpd': '평균 EPD',
                'maxEpd': '최대 EPD',
                'minEpd': '최소 EPD'
            };
            return metricNames[metric] || metric;
        }

        // 차트 단위 가져오기
        function getChartUnit(config) {
            // 건수 관련 메트릭들
            const countMetrics = ['requests', 'success', 'failed', 'tps', 'maxTps', 'avgTps', 'activeCalls', 'waitingCalls'];
            
            // 차트 ID나 메트릭에 따라 단위 결정
            if (config.id.includes('request') || config.id.includes('success') || config.id.includes('failed') || 
                config.id.includes('tps') || config.id.includes('call')) {
                return '건';
            }
            
            // 메트릭이 건수 관련인지 확인
            if (config.metrics && config.metrics.some(metric => countMetrics.includes(metric))) {
                return '건';
            }
            
            // 기본적으로 퍼센트
            return '%';
        }

        // 차트 데이터셋 생성 (공통 HW 리소스 + 서비스별 특성 반영)
        function generateChartDatasets(config, timeLabels) {
            const datasets = [];
            
            // 엔진별 색상 정의
            const engineColors = {
                'stt': ['#10b981', '#059669', '#047857'],  // 초록색 계열
                'tts': ['#3b82f6', '#2563eb', '#1d4ed8'],  // 파란색 계열
                'sv': ['#8b5cf6', '#7c3aed', '#6d28d9']    // 보라색 계열
            };
            
            const colors = engineColors[config.type] || ['#6b7280', '#4b5563', '#374151'];

            const isHWMetric = config.category === 'hw';

            // 메트릭별로 데이터셋 생성
            config.metrics.slice(0, 3).forEach((metric, index) => {
                const data = timeLabels.map(() => {
                    let value;
                    
                    if (isHWMetric) {
                        // 하드웨어 리소스 메트릭
                            if (config.id.includes('cpu')) {
                            value = Math.random() * 30 + 40; // CPU 사용률
                            } else if (config.id.includes('memory')) {
                            value = Math.random() * 25 + 45; // 메모리 사용률
                            } else if (config.id.includes('disk')) {
                            value = Math.random() * 20 + 35; // 디스크 사용률
                            } else {
                                value = Math.random() * 30 + 40; // 기본값
                            }
                        } else {
                        // 서비스 메트릭
                        value = Math.random() * config.max * 0.8 + config.max * 0.1;
                    }
                    
                    return Math.min(config.max, Math.max(0, value));
                });

                datasets.push({
                    label: getMetricDisplayName(metric),
                    data: data,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    borderWidth: 2,
                    fill: index === 0,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 4
                });
            });

            return datasets;
        }


        // 글로벌 시간 범위 적용
        function applyGlobalTimeRange() {
            globalTimeRange = document.getElementById('globalTimeRange').value;
            updateAllCharts();
        }

        // 데이터 모드 변경
        function changeDataMode() {
            dataMode = document.getElementById('dataMode').value;
            updateAllCharts();
        }

        // X축 범위 모드 변경
        function changeXAxisRangeMode() {
            xAxisRangeMode = document.getElementById('xAxisRangeMode').value;
            
            // 모든 차트의 x축 컨트롤 표시/숨김
            Object.keys(charts).forEach(chartId => {
                const xAxisControl = document.getElementById(`xAxisControl-${chartId}`);
                if (xAxisControl) {
                    xAxisControl.style.display = xAxisRangeMode === 'individual' ? 'flex' : 'none';
                }
            });
            
            if (xAxisRangeMode === 'global') {
                // 전체 설정 모드: 모든 차트에 글로벌 설정 적용
                Object.keys(charts).forEach(chartId => {
                    if (charts[chartId]) {
                        charts[chartId].options.scales.x.min = undefined;
                        charts[chartId].options.scales.x.max = undefined;
                        charts[chartId].update();
                    }
                });
            } else {
                // 차트별 설정 모드: 각 차트에 개별 설정 적용
                Object.keys(individualXAxisRanges).forEach(chartId => {
                    if (charts[chartId] && individualXAxisRanges[chartId]) {
                        const range = individualXAxisRanges[chartId];
                        charts[chartId].options.scales.x.min = range.min;
                        charts[chartId].options.scales.x.max = range.max;
                        charts[chartId].update();
                    }
                });
            }
        }

        // 개별 차트의 X축 범위 업데이트
        function updateIndividualXAxisRange(chartId) {
            const minInput = document.getElementById(`xAxisMin-${chartId}`);
            const maxInput = document.getElementById(`xAxisMax-${chartId}`);
            
            if (!minInput || !maxInput) return;
            
            const min = minInput.value ? parseFloat(minInput.value) : undefined;
            const max = maxInput.value ? parseFloat(maxInput.value) : undefined;
            
            // 개별 범위 저장
            individualXAxisRanges[chartId] = { min, max };
            
            // 차트 업데이트
            if (charts[chartId]) {
                charts[chartId].options.scales.x.min = min;
                charts[chartId].options.scales.x.max = max;
                charts[chartId].update();
            }
        }

        // 차트 시간 범위 업데이트
        function updateChartTimeRange(chartId, range) {
            if (range === '') {
                // 글로벌 설정 사용
                delete chartConfigs[chartId].timeRange;
            } else {
                chartConfigs[chartId].timeRange = range;
            }
            
            const config = chartConfigs[chartId];
            if (config) {
                const timeLabels = generateTimeLabels();
                const datasets = generateChartDatasets(config, timeLabels);
                
                const chart = charts[chartId];
                if (chart) {
                    chart.data.labels = timeLabels;
                    chart.data.datasets = datasets;
                    chart.update();
                }
            }
        }

        // 모든 차트 업데이트
        function updateAllCharts() {
            Object.keys(charts).forEach(chartId => {
                const config = chartConfigs[chartId];
                if (config) {
                    const timeLabels = generateTimeLabels();
                    const datasets = generateChartDatasets(config, timeLabels);
                    
                    const chart = charts[chartId];
                    if (chart) {
                        chart.data.labels = timeLabels;
                        chart.data.datasets = datasets;
                        chart.update('none');
                    }
                }
            });
        }

        // 전체 차트 새로고침
        function refreshAllCharts() {
            updateAllCharts();
            showNotification('모든 차트가 새로고침되었습니다.');
        }

        // 임계치 패널 표시
        function showThresholdPanel(chartId) {
            const panel = document.getElementById('thresholdPanel');
            const title = document.getElementById('thresholdTitle');
            const content = document.getElementById('thresholdContent');
            
            const config = chartConfigs[chartId];
            if (!config) return;
            
            title.textContent = `${config.name} 임계치 설정`;
            
            // 기본 임계치 설정
            if (!thresholds[chartId]) {
                thresholds[chartId] = {
                    warning: config.max * 0.7,
                    critical: config.max * 0.9
                };
            }
            
            content.innerHTML = `
                <div class="threshold-item">
                    <span class="threshold-label">경고 임계치:</span>
                    <input type="number" class="threshold-input" 
                           value="${thresholds[chartId].warning}" 
                           onchange="updateThreshold('${chartId}', 'warning', this.value)">
                    <span>${config.unit}</span>
                </div>
                <div class="threshold-item">
                    <span class="threshold-label">위험 임계치:</span>
                    <input type="number" class="threshold-input" 
                           value="${thresholds[chartId].critical}" 
                           onchange="updateThreshold('${chartId}', 'critical', this.value)">
                    <span>${config.unit}</span>
                </div>
            `;
            
            panel.style.display = 'block';
        }

        // 임계치 패널 닫기
        function closeThresholdPanel() {
            document.getElementById('thresholdPanel').style.display = 'none';
        }

        // 임계치 업데이트
        function updateThreshold(chartId, type, value) {
            if (!thresholds[chartId]) {
                thresholds[chartId] = {};
            }
            thresholds[chartId][type] = parseFloat(value);
            
            // 차트에 임계치 라인 추가
            const chart = charts[chartId];
            if (chart) {
                // 임계치 라인 업데이트 로직 추가
                chart.update();
            }
            
            showNotification(`${chartId} ${type} 임계치가 ${value}로 설정되었습니다.`);
        }

        // 상세 모달 열기
        function openDetailModal(chartId) {
            const modal = document.getElementById('detailModal');
            const title = document.getElementById('modalTitle');
            const chartContainer = document.getElementById('modalChart');
            
            const config = chartConfigs[chartId];
            if (!config) return;
            
            title.textContent = `${config.name} - 상세 정보`;
            
            // 상세 차트 생성
            chartContainer.innerHTML = '<canvas id="modalChartCanvas"></canvas>';
            
            setTimeout(() => {
                const ctx = document.getElementById('modalChartCanvas');
                if (ctx) {
                    const timeLabels = generateTimeLabels();
                    const datasets = generateChartDatasets(config, timeLabels);
                    
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: timeLabels,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: true, position: 'top' },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'minute',
                                        displayFormats: { minute: 'HH:mm' }
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    max: config.max
                                }
                            }
                        }
                    });
                }
            }, 100);
            
            modal.style.display = 'block';
        }

        // 상세 모달 닫기
        function closeDetailModal() {
            document.getElementById('detailModal').style.display = 'none';
        }

        // 차트 설정 모달 열기
        function openChartSettings(chartId) {
            const modal = document.getElementById('chartSettingsModal');
            const title = document.getElementById('chartSettingsTitle');
            const content = document.getElementById('chartSettingsContent');
            
            const config = chartConfigs[chartId];
            if (!config) return;
            
            title.textContent = `${config.name} 설정`;
            
            // 기본 임계치 설정
            if (!thresholds[chartId]) {
                thresholds[chartId] = {
                    warning: config.max * 0.7,
                    critical: config.max * 0.9
                };
            }
            
            // 개별 X축 범위 설정
            if (!individualXAxisRanges[chartId]) {
                individualXAxisRanges[chartId] = { min: undefined, max: undefined };
            }
            
            content.innerHTML = `
                <div class="settings-section">
                    <div class="settings-section-title">
                        <i class="fas fa-chart-line"></i>
                        차트 종류 설정
                    </div>
                    <div class="settings-row">
                        <span class="settings-label">차트 타입:</span>
                        <select class="settings-select" id="chartType-${chartId}">
                            <option value="line">라인 차트</option>
                            <option value="bar">바 차트</option>
                            <option value="area">영역 차트</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-section-title">
                        <i class="fas fa-clock"></i>
                        시간 범위 설정
                    </div>
                    <div class="settings-row">
                        <span class="settings-label">조회 범위:</span>
                        <select class="settings-select" id="timeRange-${chartId}">
                            <option value="">글로벌 설정 사용</option>
                            <option value="30m">30분</option>
                            <option value="1h">1시간</option>
                            <option value="3h">3시간</option>
                            <option value="6h">6시간</option>
                            <option value="12h">12시간</option>
                            <option value="24h">24시간</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-section-title">
                        <i class="fas fa-expand-arrows-alt"></i>
                        X축 범위 설정
                    </div>
                    <div class="settings-row">
                        <span class="settings-label">X축 최소값:</span>
                        <input type="number" class="settings-input" id="xAxisMin-${chartId}" 
                               placeholder="자동" value="${individualXAxisRanges[chartId].min || ''}">
                    </div>
                    <div class="settings-row">
                        <span class="settings-label">X축 최대값:</span>
                        <input type="number" class="settings-input" id="xAxisMax-${chartId}" 
                               placeholder="자동" value="${individualXAxisRanges[chartId].max || ''}">
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-section-title">
                        <i class="fas fa-sliders-h"></i>
                        임계치 설정
                    </div>
                    <div class="settings-row">
                        <span class="settings-label">경고 임계치:</span>
                        <input type="number" class="settings-input" id="warningThreshold-${chartId}" 
                               value="${thresholds[chartId].warning}" min="0" max="${config.max}">
                        <span style="margin-left: 0.5rem; color: var(--text-muted);">${config.unit}</span>
                    </div>
                    <div class="settings-row">
                        <span class="settings-label">위험 임계치:</span>
                        <input type="number" class="settings-input" id="criticalThreshold-${chartId}" 
                               value="${thresholds[chartId].critical}" min="0" max="${config.max}">
                        <span style="margin-left: 0.5rem; color: var(--text-muted);">${config.unit}</span>
                    </div>
                </div>
                
                <div class="settings-buttons">
                    <button class="settings-btn-secondary" onclick="exportChartAsSVG('${chartId}')">
                        <i class="fas fa-download"></i>
                        차트 SVG
                    </button>
                    <button class="settings-btn-secondary" onclick="exportModalAsSVG('${chartId}')">
                        <i class="fas fa-file-export"></i>
                        모달 SVG
                    </button>
                    <button class="settings-btn-secondary" onclick="closeChartSettings()">취소</button>
                    <button class="settings-btn-primary" onclick="applyChartSettings('${chartId}')">적용</button>
                </div>
            `;
            
            modal.style.display = 'block';
        }

        // 차트 설정 모달 닫기
        function closeChartSettings() {
            document.getElementById('chartSettingsModal').style.display = 'none';
        }

        // 임계치 설정 모달 열기
        function openThresholdSettings(chartId) {
            window.currentThresholdChartId = chartId;
            console.log('Opening threshold settings for chart:', chartId);
            const modal = document.getElementById('thresholdSettingsModal');
            if (modal) {
                modal.style.display = 'block';
                console.log('Modal displayed');
            } else {
                console.error('Threshold settings modal not found');
            }
        }

        // 임계치 설정 모달 닫기
        function closeThresholdSettingsModal() {
            document.getElementById('thresholdSettingsModal').style.display = 'none';
        }

        // 임계치 설정 저장
        function saveThresholdSettings() {
            const currentChartId = window.currentThresholdChartId;
            if (!currentChartId) {
                showNotification('차트 정보를 찾을 수 없습니다.');
                return;
            }

            const maxEnabled = document.getElementById('maxThresholdEnabled').checked;
            const maxValue = parseFloat(document.getElementById('maxThresholdValue').value);
            const minEnabled = document.getElementById('minThresholdEnabled').checked;
            const minValue = parseFloat(document.getElementById('minThresholdValue').value);
            const avgEnabled = document.getElementById('avgThresholdEnabled').checked;
            
            // 차트에 임계치 설정 적용
            applyThresholdToChart(currentChartId, {
                max: { enabled: maxEnabled, value: maxValue },
                min: { enabled: minEnabled, value: minValue },
                avg: { enabled: avgEnabled }
            });
            
            closeThresholdSettingsModal();
            showNotification(`${currentChartId} 차트의 임계치 설정이 적용되었습니다.`);
        }

        // 차트에 임계치 적용
        function applyThresholdToChart(chartId, thresholdSettings) {
            const chartElement = document.getElementById(`chart-${chartId}`);
            if (chartElement && chartElement.chart) {
                const chart = chartElement.chart;
                
                // Chart.js annotation 플러그인을 사용하여 임계치 선 그리기
                if (!chart.options.plugins.annotation) {
                    chart.options.plugins.annotation = {
                        annotations: {}
                    };
                }

                const annotations = {};

                // MAX 임계치 선
                if (thresholdSettings.max.enabled) {
                    annotations.maxThreshold = {
                        type: 'line',
                        yMin: thresholdSettings.max.value,
                        yMax: thresholdSettings.max.value,
                        borderColor: '#ef4444',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            content: `MAX: ${thresholdSettings.max.value}%`,
                            enabled: true,
                            position: 'end'
                        }
                    };
                }

                // MIN 임계치 선
                if (thresholdSettings.min.enabled) {
                    annotations.minThreshold = {
                        type: 'line',
                        yMin: thresholdSettings.min.value,
                        yMax: thresholdSettings.min.value,
                        borderColor: '#f59e0b',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            content: `MIN: ${thresholdSettings.min.value}%`,
                            enabled: true,
                            position: 'end'
                        }
                    };
                }

                // 평균선
                if (thresholdSettings.avg.enabled) {
                    // 실제 데이터의 평균값 계산
                    const avgValue = calculateAverageValue(chart.data.datasets);
                    annotations.avgThreshold = {
                        type: 'line',
                        yMin: avgValue,
                        yMax: avgValue,
                        borderColor: '#10b981',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            content: `AVG: ${avgValue.toFixed(1)}%`,
                            enabled: true,
                            position: 'end'
                        }
                    };
                }

                chart.options.plugins.annotation.annotations = annotations;
                chart.update();
            }
        }

        // 데이터의 평균값 계산
        function calculateAverageValue(datasets) {
            let totalSum = 0;
            let totalCount = 0;

            datasets.forEach(dataset => {
                if (dataset.data && Array.isArray(dataset.data)) {
                    dataset.data.forEach(value => {
                        if (typeof value === 'number') {
                            totalSum += value;
                            totalCount++;
                        }
                    });
                }
            });

            return totalCount > 0 ? totalSum / totalCount : 0;
        }

        // 기간조회 모달 열기
        function openPeriodQuery(chartId) {
            window.currentPeriodChartId = chartId;
            const modal = document.getElementById('periodQueryModal');
            if (modal) {
                modal.style.display = 'block';
                loadPeriodSettings(chartId);
            }
        }

        // 기간조회 모달 닫기
        function closePeriodQueryModal() {
            const modal = document.getElementById('periodQueryModal');
            if (modal) {
                modal.style.display = 'none';
            }
            window.currentPeriodChartId = null;
        }

        // 전체 설정을 따름 토글
        function toggleIndividualPeriod() {
            const followGlobal = document.getElementById('followGlobalSettings');
            const individualSettings = document.getElementById('individualPeriodSettings');
            
            // 조회화면은 항상 보이고 활성화 상태로 유지
            individualSettings.style.display = 'block';
            
            // 조회 화면의 모든 요소는 항상 활성화 상태 유지
            const allInputs = individualSettings.querySelectorAll('input, select, button');
            allInputs.forEach(input => {
                input.disabled = false;
                input.style.opacity = '1';
            });
            
            // 전체 설정을 따름 체크박스는 단순히 UI 표시용으로만 사용
            // 실제 기능적 연관성은 없음
        }

        // 기간조회 설정 로드
        function loadPeriodSettings(chartId) {
            // 차트별 설정 로드 (현재는 기본값으로 설정)
            const followGlobal = document.getElementById('followGlobalSettings');
            const individualSettings = document.getElementById('individualPeriodSettings');
            
            if (followGlobal && individualSettings) {
                // 전체 설정을 따름은 기본적으로 체크 해제 상태
                followGlobal.checked = false;
                
                // 조회 화면은 항상 보이고 활성화 상태로 유지
                individualSettings.style.display = 'block';
                
                // 모든 입력 요소를 항상 활성화 상태로 유지
                const inputs = individualSettings.querySelectorAll('input, select, button');
                inputs.forEach(input => {
                    input.disabled = false;
                    input.style.opacity = '1';
                });
            }
        }

        // 기간조회 설정 적용
        function applyPeriodQuery() {
            const chartId = window.currentPeriodChartId;
            if (!chartId) {
                showNotification('차트 정보를 찾을 수 없습니다.');
                return;
            }

            // 기간조회 설정 적용 로직
            console.log('기간조회 설정 적용:', chartId);
            closePeriodQueryModal();
            showNotification(`${chartId} 차트의 기간조회 설정이 적용되었습니다.`);
        }

        // 차트설정 모달 열기
        function openChartSettings(chartId) {
            console.log('openChartSettings 호출됨, chartId:', chartId);
            
            // 이미 모달이 열려있는지 확인
            const modal = document.getElementById('chartSettingsModal');
            if (modal && modal.style.display === 'block') {
                console.log('모달이 이미 열려있습니다. 중복 호출 방지.');
                return;
            }
            
            window.currentChartSettingsId = chartId;
            console.log('모달 요소:', modal);
            
            if (modal) {
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.zIndex = '1000';
                console.log('모달 표시됨');
                initializePreviewChart();
                
                // 적용 버튼에 직접 이벤트 리스너 추가
                const applyButton = modal.querySelector('#applyButton');
                const cancelButton = modal.querySelector('#cancelButton');
                
                if (applyButton) {
                    console.log('적용 버튼 찾음:', applyButton);
                    
                    // 기존 이벤트 리스너 모두 제거
                    const newApplyButton = applyButton.cloneNode(true);
                    applyButton.parentNode.replaceChild(newApplyButton, applyButton);
                    
                    // 새로운 이벤트 리스너 추가
                    newApplyButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🚀🚀🚀🚀🚀 적용 버튼 클릭됨! 🚀🚀🚀🚀🚀');
                        applyChartSettings();
                        return false;
                    });
                    
                    // onclick 속성도 추가
                    newApplyButton.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🚀🚀🚀🚀🚀 적용 버튼 onclick! 🚀🚀🚀🚀🚀');
                        applyChartSettings();
                        return false;
                    };
                    
                    console.log('적용 버튼 이벤트 리스너 등록 완료');
                } else {
                    console.error('적용 버튼을 찾을 수 없습니다!');
                }
                
                if (cancelButton) {
                    console.log('취소 버튼 찾음:', cancelButton);
                    cancelButton.addEventListener('click', function() {
                        console.log('🚀 취소 버튼 클릭됨!');
                        closeChartSettings();
                    });
                } else {
                    console.error('취소 버튼을 찾을 수 없습니다!');
                }
                
                // 모달 외부 클릭으로 닫기 이벤트 추가
                modal.onclick = function(event) {
                    if (event.target === modal) {
                        console.log('모달 외부 클릭으로 닫기');
                        closeChartSettings();
                    }
                };
                
                // ESC 키로 닫기 이벤트 추가
                document.addEventListener('keydown', function(event) {
                    if (event.key === 'Escape' && modal.style.display === 'block') {
                        console.log('ESC 키로 모달 닫기');
                        closeChartSettings();
                    }
                });
            } else {
                console.error('차트설정 모달을 찾을 수 없습니다.');
                alert('차트설정 기능을 준비 중입니다.');
            }
        }

        // 차트 설정 모달 닫기
        function closeChartSettings() {
            console.log('closeChartSettings 호출됨');
            const modal = document.getElementById('chartSettingsModal');
            console.log('모달 요소:', modal);
            
            if (modal) {
                modal.style.display = 'none';
                console.log('모달이 닫혔습니다.');
            } else {
                console.error('차트설정 모달을 찾을 수 없습니다.');
            }
        }

        // 선차트 생성
        function createLineChart(data1, data2, labels, svgWidth, svgHeight, padding, chartWidth, chartHeight, comparePrevious, yAxisMax, yAxisMaxValue, showMaxThreshold, maxThresholdValue, showAverageLine, showMinThreshold, minThresholdValue) {
            const dataMaxValue = Math.max(...data1, ...data2);
            const dataMinValue = Math.min(...data1, ...data2);
            
            // Y축 최대값 설정 적용
            let maxValue, minValue;
            if (yAxisMax === 'fixed' && yAxisMaxValue) {
                maxValue = parseInt(yAxisMaxValue);
                minValue = 0; // 고정값 사용 시 최소값은 0
            } else {
                maxValue = dataMaxValue;
                minValue = Math.max(0, dataMinValue); // 최소값이 0보다 작으면 0으로 설정
            }
            
            // 값 범위가 0이 되지 않도록 보장
            if (maxValue === minValue) {
                maxValue = minValue + 1;
            }
            
            const valueRange = maxValue - minValue;
            
            let svg = '';
            
            // 격자 그리기 및 Y축 라벨
            for (let i = 0; i <= 4; i++) {
                const y = padding + (chartHeight / 4) * i;
                const value = maxValue - (valueRange / 4) * i;
                svg += `<line x1="${padding}" y1="${y}" x2="${padding + chartWidth}" y2="${y}" stroke="#e9ecef" stroke-width="1"/>`;
                svg += `<text x="${padding - 5}" y="${y + 4}" font-size="10" fill="#6c757d" text-anchor="end">${Math.round(value)}</text>`;
            }
            
            // 데이터 포인트를 좌표로 변환
            const points1 = data1.map((value, index) => {
                const x = padding + (chartWidth / (data1.length - 1)) * index;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                return `${x},${y}`;
            }).join(' ');
            
            const points2 = data2.map((value, index) => {
                const x = padding + (chartWidth / (data2.length - 1)) * index;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                return `${x},${y}`;
            }).join(' ');
            
            // 선 그리기
            svg += `<polyline points="${points1}" fill="none" stroke="#007bff" stroke-width="2"/>`;
            svg += `<polyline points="${points2}" fill="none" stroke="#28a745" stroke-width="2"/>`;
            
            // 데이터 포인트 그리기
            data1.forEach((value, index) => {
                const x = padding + (chartWidth / (data1.length - 1)) * index;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                svg += `<circle cx="${x}" cy="${y}" r="3" fill="#007bff"/>`;
            });
            
            data2.forEach((value, index) => {
                const x = padding + (chartWidth / (data2.length - 1)) * index;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                svg += `<circle cx="${x}" cy="${y}" r="3" fill="#28a745"/>`;
            });
            
            // 이전 시간과 비교 (점선)
            if (comparePrevious) {
                const prevPoints1 = data1.map((value, index) => {
                    const x = padding + (chartWidth / (data1.length - 1)) * index;
                    const y = padding + chartHeight - ((value * 0.7 - minValue) / valueRange) * chartHeight;
                    return `${x},${y}`;
                }).join(' ');
                
                const prevPoints2 = data2.map((value, index) => {
                    const x = padding + (chartWidth / (data2.length - 1)) * index;
                    const y = padding + chartHeight - ((value * 0.7 - minValue) / valueRange) * chartHeight;
                    return `${x},${y}`;
                }).join(' ');
                
                svg += `<polyline points="${prevPoints1}" fill="none" stroke="#6c757d" stroke-width="2" stroke-dasharray="5,5"/>`;
                svg += `<polyline points="${prevPoints2}" fill="none" stroke="#6c757d" stroke-width="2" stroke-dasharray="5,5"/>`;
            }
            
            return svg;
        }
        
        // 막대차트 생성
        function createBarChart(data1, data2, labels, svgWidth, svgHeight, padding, chartWidth, chartHeight, comparePrevious, yAxisMax, yAxisMaxValue, showMaxThreshold, maxThresholdValue, showAverageLine, showMinThreshold, minThresholdValue) {
            const dataMaxValue = Math.max(...data1, ...data2);
            const dataMinValue = Math.min(...data1, ...data2);
            
            // Y축 최대값 설정 적용
            let maxValue, minValue;
            if (yAxisMax === 'fixed' && yAxisMaxValue) {
                maxValue = parseInt(yAxisMaxValue);
                minValue = 0;
            } else {
                maxValue = dataMaxValue;
                minValue = Math.max(0, dataMinValue); // 최소값이 0보다 작으면 0으로 설정
            }
            
            // 값 범위가 0이 되지 않도록 보장
            if (maxValue === minValue) {
                maxValue = minValue + 1;
            }
            
            const valueRange = maxValue - minValue;
            
            let svg = '';
            
            // 격자 그리기 및 Y축 라벨
            for (let i = 0; i <= 4; i++) {
                const y = padding + (chartHeight / 4) * i;
                const value = maxValue - (valueRange / 4) * i;
                svg += `<line x1="${padding}" y1="${y}" x2="${padding + chartWidth}" y2="${y}" stroke="#e9ecef" stroke-width="1"/>`;
                svg += `<text x="${padding - 5}" y="${y + 4}" font-size="10" fill="#6c757d" text-anchor="end">${Math.round(value)}</text>`;
            }
            
            const barWidth = chartWidth / (data1.length * 2.5);
            const barSpacing = chartWidth / data1.length;
            
            // 막대 그리기
            data1.forEach((value, index) => {
                const x = padding + barSpacing * index + barSpacing * 0.1;
                const height = Math.max(1, ((value - minValue) / valueRange) * chartHeight); // 최소 높이 1px 보장
                const y = padding + chartHeight - height;
                
                svg += `<rect x="${x}" y="${y}" width="${barWidth}" height="${height}" fill="#007bff" opacity="0.8"/>`;
            });
            
            data2.forEach((value, index) => {
                const x = padding + barSpacing * index + barSpacing * 0.1 + barWidth + 2;
                const height = Math.max(1, ((value - minValue) / valueRange) * chartHeight); // 최소 높이 1px 보장
                const y = padding + chartHeight - height;
                
                svg += `<rect x="${x}" y="${y}" width="${barWidth}" height="${height}" fill="#28a745" opacity="0.8"/>`;
            });
            
            // 이전 시간과 비교 (반투명 막대)
            if (comparePrevious) {
                data1.forEach((value, index) => {
                    const x = padding + barSpacing * index + barSpacing * 0.1;
                    const height = Math.max(1, ((value * 0.7 - minValue) / valueRange) * chartHeight); // 최소 높이 1px 보장
                    const y = padding + chartHeight - height;
                    
                    svg += `<rect x="${x}" y="${y}" width="${barWidth}" height="${height}" fill="#6c757d" opacity="0.3"/>`;
                });
                
                data2.forEach((value, index) => {
                    const x = padding + barSpacing * index + barSpacing * 0.1 + barWidth + 2;
                    const height = Math.max(1, ((value * 0.7 - minValue) / valueRange) * chartHeight); // 최소 높이 1px 보장
                    const y = padding + chartHeight - height;
                    
                    svg += `<rect x="${x}" y="${y}" width="${barWidth}" height="${height}" fill="#6c757d" opacity="0.3"/>`;
                });
            }
            
            // 임계치 선 그리기
            if (showMaxThreshold && maxThresholdValue) {
                const thresholdY = padding + chartHeight - ((parseInt(maxThresholdValue) - minValue) / valueRange) * chartHeight;
                svg += `<line x1="${padding}" y1="${thresholdY}" x2="${padding + chartWidth}" y2="${thresholdY}" stroke="#dc3545" stroke-width="2" stroke-dasharray="5,5" opacity="0.8"/>`;
                svg += `<text x="${padding + chartWidth - 5}" y="${thresholdY - 5}" font-size="10" fill="#dc3545">MAX: ${maxThresholdValue}%</text>`;
            }
            
            if (showMinThreshold && minThresholdValue) {
                const thresholdY = padding + chartHeight - ((parseInt(minThresholdValue) - minValue) / valueRange) * chartHeight;
                svg += `<line x1="${padding}" y1="${thresholdY}" x2="${padding + chartWidth}" y2="${thresholdY}" stroke="#ffc107" stroke-width="2" stroke-dasharray="5,5" opacity="0.8"/>`;
                svg += `<text x="${padding + chartWidth - 5}" y="${thresholdY + 15}" font-size="10" fill="#ffc107">MIN: ${minThresholdValue}%</text>`;
            }
            
            if (showAverageLine) {
                const avgValue = (dataMaxValue + dataMinValue) / 2;
                const avgY = padding + chartHeight - ((avgValue - minValue) / valueRange) * chartHeight;
                svg += `<line x1="${padding}" y1="${avgY}" x2="${padding + chartWidth}" y2="${avgY}" stroke="#28a745" stroke-width="2" stroke-dasharray="3,3" opacity="0.8"/>`;
                svg += `<text x="${padding + chartWidth - 5}" y="${avgY - 5}" font-size="10" fill="#28a745">AVG: ${Math.round(avgValue)}%</text>`;
            }
            
            return svg;
        }
        
        // 영역차트 생성
        function createAreaChart(data1, data2, labels, svgWidth, svgHeight, padding, chartWidth, chartHeight, comparePrevious, yAxisMax, yAxisMaxValue, showMaxThreshold, maxThresholdValue, showAverageLine, showMinThreshold, minThresholdValue) {
            const dataMaxValue = Math.max(...data1, ...data2);
            const dataMinValue = Math.min(...data1, ...data2);
            
            // Y축 최대값 설정 적용
            let maxValue, minValue;
            if (yAxisMax === 'fixed' && yAxisMaxValue) {
                maxValue = parseInt(yAxisMaxValue);
                minValue = 0;
            } else {
                maxValue = dataMaxValue;
                minValue = Math.max(0, dataMinValue); // 최소값이 0보다 작으면 0으로 설정
            }
            
            // 값 범위가 0이 되지 않도록 보장
            if (maxValue === minValue) {
                maxValue = minValue + 1;
            }
            
            const valueRange = maxValue - minValue;
            
            let svg = '';
            
            // 격자 그리기 및 Y축 라벨
            for (let i = 0; i <= 4; i++) {
                const y = padding + (chartHeight / 4) * i;
                const value = maxValue - (valueRange / 4) * i;
                svg += `<line x1="${padding}" y1="${y}" x2="${padding + chartWidth}" y2="${y}" stroke="#e9ecef" stroke-width="1"/>`;
                svg += `<text x="${padding - 5}" y="${y + 4}" font-size="10" fill="#6c757d" text-anchor="end">${Math.round(value)}</text>`;
            }
            
            // 영역1 그리기
            const points1 = data1.map((value, index) => {
                const x = padding + (chartWidth / (data1.length - 1)) * index;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                return `${x},${y}`;
            });
            
            const area1Path = `M ${points1[0]} L ${points1.slice(1).join(' L ')} L ${padding + chartWidth},${padding + chartHeight} L ${padding},${padding + chartHeight} Z`;
            svg += `<path d="${area1Path}" fill="url(#gradient1)" stroke="#007bff" stroke-width="2"/>`;
            
            // 영역2 그리기
            const points2 = data2.map((value, index) => {
                const x = padding + (chartWidth / (data2.length - 1)) * index;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                return `${x},${y}`;
            });
            
            const area2Path = `M ${points2[0]} L ${points2.slice(1).join(' L ')} L ${padding + chartWidth},${padding + chartHeight} L ${padding},${padding + chartHeight} Z`;
            svg += `<path d="${area2Path}" fill="url(#gradient2)" stroke="#28a745" stroke-width="2"/>`;
            
            // 그라데이션 정의
            svg = `<defs>
                <linearGradient id="gradient1" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#007bff;stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:#007bff;stop-opacity:0.1" />
                </linearGradient>
                <linearGradient id="gradient2" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#28a745;stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:#28a745;stop-opacity:0.1" />
                </linearGradient>
            </defs>` + svg;
            
            // 이전 시간과 비교 (점선)
            if (comparePrevious) {
                const prevPoints1 = data1.map((value, index) => {
                    const x = padding + (chartWidth / (data1.length - 1)) * index;
                    const y = padding + chartHeight - ((value * 0.7 - minValue) / valueRange) * chartHeight;
                    return `${x},${y}`;
                }).join(' ');
                
                const prevPoints2 = data2.map((value, index) => {
                    const x = padding + (chartWidth / (data2.length - 1)) * index;
                    const y = padding + chartHeight - ((value * 0.7 - minValue) / valueRange) * chartHeight;
                    return `${x},${y}`;
                }).join(' ');
                
                svg += `<polyline points="${prevPoints1}" fill="none" stroke="#6c757d" stroke-width="2" stroke-dasharray="5,5"/>`;
                svg += `<polyline points="${prevPoints2}" fill="none" stroke="#6c757d" stroke-width="2" stroke-dasharray="5,5"/>`;
            }
            
            return svg;
        }
        
        // 범례 생성
        function createLegend(svgWidth, svgHeight) {
            const legendX = svgWidth - 100;
            const legendY = 20;
            
            return `
                <g>
                    <rect x="${legendX}" y="${legendY}" width="90" height="50" fill="white" stroke="#dee2e6" rx="4"/>
                    <line x1="${legendX + 10}" y1="${legendY + 15}" x2="${legendX + 25}" y2="${legendY + 15}" stroke="#007bff" stroke-width="2"/>
                    <text x="${legendX + 30}" y="${legendY + 20}" font-size="12" fill="#495057">서버 1</text>
                    <line x1="${legendX + 10}" y1="${legendY + 35}" x2="${legendX + 25}" y2="${legendY + 35}" stroke="#28a745" stroke-width="2"/>
                    <text x="${legendX + 30}" y="${legendY + 40}" font-size="12" fill="#495057">서버 2</text>
                </g>
            `;
        }

        // 미리보기 차트 초기화
        function initializePreviewChart() {
            console.log('initializePreviewChart 호출됨');
            
            // 미리보기 컨테이너 찾기
            const container = document.querySelector('.preview-chart-container');
            console.log('미리보기 컨테이너:', container);
            
            if (!container) {
                console.error('미리보기 차트 컨테이너를 찾을 수 없습니다.');
                return;
            }

            // SVG 기반 미리보기 초기화
            container.innerHTML = `
                <div style="width: 100%; height: 150px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; display: flex; align-items: center; justify-content: center; flex-direction: column;">
                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 10px;">미리보기 차트</div>
                    <div style="font-size: 12px; color: #adb5bd;">설정을 변경하면 여기에 미리보기가 표시됩니다</div>
                </div>
            `;
            
            console.log('미리보기 차트 영역 초기화 완료');
            
            // 초기 미리보기 업데이트
            updatePreviewChart();
        }

        // 미리보기 차트 업데이트
        function updatePreviewChart() {
            console.log('updatePreviewChart 호출됨');
            
            try {
                // 현재 설정값들 가져오기
                const chartType = document.querySelector('input[name="chartType"]:checked')?.value || 'line';
                const showLegend = document.getElementById('showLegend')?.checked || false;
                const showMaxValue = document.getElementById('showMaxValue')?.checked || false;
                const comparePrevious = document.getElementById('comparePrevious')?.checked || false;
                const yAxisMax = document.querySelector('input[name="yAxisMax"]:checked')?.value || 'auto';
                const yAxisMaxValue = document.getElementById('yAxisMaxValue')?.value || '100';
                
                // 임계치 설정 가져오기
                const showMaxThreshold = document.getElementById('showMaxThreshold')?.checked || false;
                const maxThresholdValue = document.getElementById('maxThresholdValue')?.value || '90';
                const showAverageLine = document.getElementById('showAverageLine')?.checked || false;
                const showMinThreshold = document.getElementById('showMinThreshold')?.checked || false;
                const minThresholdValue = document.getElementById('minThresholdValue')?.value || '10';

                console.log('설정값들:', { 
                    chartType, showLegend, showMaxValue, comparePrevious, yAxisMax, yAxisMaxValue,
                    showMaxThreshold, maxThresholdValue, showAverageLine, showMinThreshold, minThresholdValue
                });

                // 미리보기 영역 업데이트
                const container = document.querySelector('.preview-chart-container');
                console.log('미리보기 컨테이너:', container);
                if (container) {
                    // 샘플 데이터
                    const data1 = [20, 25, 30, 35, 40, 45, 50, 55, 60, 65];
                    const data2 = [15, 20, 25, 30, 35, 40, 45, 50, 55, 60];
                    const labels = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                    
                    // SVG 차트 생성
                    const svgWidth = 400;
                    const svgHeight = 150;
                    const padding = 20;
                    const chartWidth = svgWidth - padding * 2;
                    const chartHeight = svgHeight - padding * 2;
                    
                    let svgContent = '';
                    
                    if (chartType === 'line') {
                        // 선차트
                        svgContent = createLineChart(data1, data2, labels, svgWidth, svgHeight, padding, chartWidth, chartHeight, comparePrevious, yAxisMax, yAxisMaxValue, showMaxThreshold, maxThresholdValue, showAverageLine, showMinThreshold, minThresholdValue);
                    } else if (chartType === 'bar') {
                        // 막대차트
                        svgContent = createBarChart(data1, data2, labels, svgWidth, svgHeight, padding, chartWidth, chartHeight, comparePrevious, yAxisMax, yAxisMaxValue, showMaxThreshold, maxThresholdValue, showAverageLine, showMinThreshold, minThresholdValue);
                    } else if (chartType === 'area') {
                        // 영역차트
                        svgContent = createAreaChart(data1, data2, labels, svgWidth, svgHeight, padding, chartWidth, chartHeight, comparePrevious, yAxisMax, yAxisMaxValue, showMaxThreshold, maxThresholdValue, showAverageLine, showMinThreshold, minThresholdValue);
                    }
                    
                    // 범례 추가
                    if (showLegend) {
                        svgContent += createLegend(svgWidth, svgHeight);
                    }
                    
                    container.innerHTML = `
                        <div style="width: 100%; height: 150px; background: white; border: 1px solid #dee2e6; border-radius: 4px; overflow: hidden;">
                            <svg width="100%" height="100%" viewBox="0 0 ${svgWidth} ${svgHeight}" style="display: block;">
                                ${svgContent}
                            </svg>
                        </div>
                    `;
                }

                // 토글 텍스트 업데이트
                const compareText = document.getElementById('compareText');
                const maxValueText = document.getElementById('maxValueText');
                const legendText = document.getElementById('legendText');
                
                if (compareText) compareText.textContent = comparePrevious ? 'ON' : 'OFF';
                if (maxValueText) maxValueText.textContent = showMaxValue ? 'ON' : 'OFF';
                if (legendText) legendText.textContent = showLegend ? 'ON' : 'OFF';

                console.log('미리보기 업데이트 완료');
                
            } catch (error) {
                console.error('미리보기 차트 업데이트 오류:', error);
            }
        }

        // Y축 고정 토글
        function toggleYAxisFixed() {
            const yAxisFixedInput = document.getElementById('yAxisFixedInput');
            const fixedRadio = document.querySelector('input[name="yAxisMax"][value="fixed"]');
            
            if (fixedRadio.checked) {
                yAxisFixedInput.style.display = 'block';
            } else {
                yAxisFixedInput.style.display = 'none';
            }
            updatePreviewChart();
        }

        // 차트 설정 적용
        function applyChartSettings() {
            console.log('🚀🚀🚀🚀🚀🚀🚀 applyChartSettings 함수 시작 🚀🚀🚀🚀🚀🚀🚀');
            
            // 즉시 모달 닫기 (가장 먼저)
            const modal = document.getElementById('chartSettingsModal');
            if (modal) {
                console.log('🚀 즉시 모달 닫기 시작');
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.style.opacity = '0';
                modal.style.zIndex = '-1';
                modal.classList.remove('show');
                console.log('🚀 즉시 모달 닫기 완료');
            }
            
            const chartId = window.currentChartSettingsId;
            console.log('🚀 현재 차트 ID:', chartId);
            
            // 차트 설정 적용 시도
            try {
                if (!chartId) {
                    console.log('차트 ID가 없습니다.');
                    showNotification('차트 ID가 없습니다.');
                    return;
                }

                // 실제 차트에 설정 적용
                const chartElement = document.getElementById(`chart-${chartId}`);
                const chart = chartElement ? chartElement.chart : null;
                console.log('차트 요소:', chartElement);
                console.log('차트 인스턴스:', chart);
                
                if (chart) {
                    const chartType = document.querySelector('input[name="chartType"]:checked')?.value || 'line';
                    const showLegend = document.getElementById('showLegend')?.checked || false;
                    const yAxisMax = document.querySelector('input[name="yAxisMax"]:checked')?.value || 'auto';
                    const yAxisMaxValue = document.getElementById('yAxisMaxValue')?.value || '100';
                    
                    console.log('🚀 적용할 설정들:');
                    console.log('- 차트 타입:', chartType);
                    console.log('- 범례 표시:', showLegend);
                    console.log('- Y축 최대값:', yAxisMax);
                    console.log('- Y축 고정값:', yAxisMaxValue);

                    // 범례 표시/숨김
                    if (chart.options && chart.options.plugins) {
                        chart.options.plugins.legend.display = showLegend;
                        console.log('🚀 범례 설정 적용됨:', showLegend);
                    }
                    
                    // Y축 최대값 설정
                    if (chart.options && chart.options.scales && chart.options.scales.y) {
                        if (yAxisMax === 'fixed' && yAxisMaxValue) {
                            chart.options.scales.y.max = parseInt(yAxisMaxValue);
                            chart.options.scales.y.min = 0;
                            console.log('🚀 Y축 고정값 설정됨:', parseInt(yAxisMaxValue));
                        } else {
                            chart.options.scales.y.max = undefined;
                            chart.options.scales.y.min = undefined;
                            console.log('🚀 Y축 자동값 설정됨');
                        }
                    }


                    // 차트 업데이트
                    console.log('🚀 차트 업데이트 시작...');
                    chart.update('active');
                    console.log('🚀 차트 업데이트 완료');
                } else {
                    console.log('차트 인스턴스를 찾을 수 없습니다.');
                    showNotification('차트를 찾을 수 없습니다.');
                }
            } catch (error) {
                console.error('차트 설정 적용 중 오류:', error);
                showNotification('차트 설정 적용 중 오류가 발생했습니다.');
            }
            
            console.log('알림 표시 전...');
            showNotification('차트 설정이 적용되었습니다.');
            console.log('차트 설정 적용 완료');
        }
        
        // 전역 함수로도 등록 (추가 보장)
        window.applyChartSettings = applyChartSettings;
        console.log('전역 applyChartSettings 함수 등록 완료');

        // 조회설정 모달 열기
        function openQuerySettings(chartId) {
            window.currentQueryChartId = chartId;
            document.getElementById('querySettingsModal').style.display = 'block';
            
            // 해당 차트의 기존 설정 불러오기
            const existingSettings = loadChartQuerySettings(chartId);
            if (existingSettings) {
                loadQuerySettingsToModal(existingSettings);
            } else {
                // 기본값으로 초기화
                setTimeout(() => {
                    initializeDateInputs();
                }, 100);
            }
        }

        // 조회설정을 모달에 로드
        function loadQuerySettingsToModal(settings) {
            // Y축 범위 설정
            if (settings.yAxisMode) {
                const yAxisRadio = document.querySelector(`input[name="yAxisRange"][value="${settings.yAxisMode}"]`);
                if (yAxisRadio) {
                    yAxisRadio.checked = true;
                }
            }
            
            // Y축 최소/최대값
            if (settings.yAxisMin) {
                document.getElementById('yAxisMin').value = settings.yAxisMin;
            }
            if (settings.yAxisMax) {
                document.getElementById('yAxisMax').value = settings.yAxisMax;
            }
            
            // 데이터 간격
            if (settings.dataInterval) {
                const dataIntervalSelect = document.querySelector('.data-interval');
                if (dataIntervalSelect) {
                    dataIntervalSelect.value = settings.dataInterval;
                }
            }
            
            // 시계열 차트 설정
            if (settings.timeSeriesEnabled !== undefined) {
                document.getElementById('timeSeriesEnabled').checked = settings.timeSeriesEnabled;
            }
            if (settings.comparisonPeriod) {
                document.getElementById('comparisonPeriod').value = settings.comparisonPeriod;
            }
            if (settings.comparisonColor) {
                document.getElementById('comparisonColor').value = settings.comparisonColor;
            }
            
            // 조회기간 설정
            if (settings.duration) {
                document.getElementById('durationValue').value = settings.duration;
            }
        }

        // 조회설정 모달 닫기
        function closeQuerySettingsModal() {
            document.getElementById('querySettingsModal').style.display = 'none';
        }

        // 조회설정 저장
        function saveQuerySettings() {
            const currentChartId = window.currentQueryChartId;
            if (!currentChartId) {
                showNotification('차트 정보를 찾을 수 없습니다.');
                return;
            }

            const duration = document.getElementById('durationValue').value;
            const dataInterval = document.querySelector('.data-interval').value;
            const yAxisMin = document.getElementById('yAxisMin').value;
            const yAxisMax = document.getElementById('yAxisMax').value;
            const timeSeriesEnabled = document.getElementById('timeSeriesEnabled').checked;
            const comparisonPeriod = document.getElementById('comparisonPeriod').value;
            const comparisonColor = document.getElementById('comparisonColor').value;
            const yAxisMode = document.querySelector('input[name="yAxisRange"]:checked').value;
            
            // 차트별 설정 저장
            const querySettings = {
                duration: duration,
                dataInterval: dataInterval,
                yAxisMin: yAxisMin,
                yAxisMax: yAxisMax,
                yAxisMode: yAxisMode,
                timeSeriesEnabled: timeSeriesEnabled,
                comparisonPeriod: comparisonPeriod,
                comparisonColor: comparisonColor
            };
            
            // 차트별 설정 저장
            saveChartQuerySettings(currentChartId, querySettings);
            
            // 차트에 조회설정 적용
            applyQueryToChart(currentChartId, querySettings);
            
            closeQuerySettingsModal();
            showNotification(`${currentChartId} 차트의 조회설정이 적용되었습니다.`);
        }

        // 차트별 조회설정 저장
        function saveChartQuerySettings(chartId, settings) {
            if (!window.chartQuerySettings) {
                window.chartQuerySettings = {};
            }
            window.chartQuerySettings[chartId] = settings;
        }

        // 차트별 조회설정 불러오기
        function loadChartQuerySettings(chartId) {
            if (!window.chartQuerySettings || !window.chartQuerySettings[chartId]) {
                return null;
            }
            return window.chartQuerySettings[chartId];
        }

        // 차트에 조회설정 적용
        function applyQueryToChart(chartId, querySettings) {
            const chartElement = document.getElementById(`chart-${chartId}`);
            if (chartElement && chartElement.chart) {
                const chart = chartElement.chart;
                
                console.log('차트 ID:', chartId);
                console.log('조회설정:', querySettings);
                
                // Y축 범위 설정
                if (querySettings.yAxisMode === 'fixedRange' && querySettings.yAxisMin && querySettings.yAxisMax) {
                    // 고정 범위
                    const minValue = parseFloat(querySettings.yAxisMin);
                    const maxValue = parseFloat(querySettings.yAxisMax);
                    console.log('고정 범위 설정:', minValue, '~', maxValue);
                    
                    chart.options.scales.y.min = minValue;
                    chart.options.scales.y.max = maxValue;
                    chart.options.scales.y.ticks.min = minValue;
                    chart.options.scales.y.ticks.max = maxValue;
                } else if (querySettings.yAxisMode === 'autoRange') {
                    // MAX 기준 자동 조정
                    const autoRange = calculateAutoYAxisRange(chart.data.datasets);
                    console.log('자동 범위 계산:', autoRange);
                    
                    chart.options.scales.y.min = autoRange.min;
                    chart.options.scales.y.max = autoRange.max;
                    chart.options.scales.y.ticks.min = autoRange.min;
                    chart.options.scales.y.ticks.max = autoRange.max;
                }
                
                // Y축 설정 강제 업데이트
                chart.options.scales.y.ticks.suggestedMin = chart.options.scales.y.min;
                chart.options.scales.y.ticks.suggestedMax = chart.options.scales.y.max;
                
                // 데이터 간격에 따른 시간 라벨 업데이트
                if (querySettings.dataInterval) {
                    updateTimeLabels(chart, querySettings.dataInterval);
                }
                
                // 시계열 차트 설정
                if (querySettings.timeSeriesEnabled) {
                    // 비교 기간 데이터 추가 (실제 구현에서는 서버에서 데이터를 가져와야 함)
                    addComparisonData(chart, querySettings.comparisonPeriod, querySettings.comparisonColor);
                }
                
                console.log('차트 업데이트 전 Y축 설정:', chart.options.scales.y);
                chart.update('none'); // 애니메이션 없이 즉시 업데이트
                console.log('차트 업데이트 후 Y축 설정:', chart.options.scales.y);
            } else {
                console.error('차트를 찾을 수 없습니다:', chartId);
            }
        }

        // MAX 기준 자동 Y축 범위 계산
        function calculateAutoYAxisRange(datasets) {
            let maxValue = 0;
            let minValue = Infinity;
            
            console.log('데이터셋 분석 시작:', datasets);
            
            // 모든 데이터셋에서 최대값과 최소값 찾기
            datasets.forEach((dataset, index) => {
                console.log(`데이터셋 ${index}:`, dataset.data);
                if (dataset.data && Array.isArray(dataset.data)) {
                    dataset.data.forEach((value, valueIndex) => {
                        if (typeof value === 'number') {
                            maxValue = Math.max(maxValue, value);
                            minValue = Math.min(minValue, value);
                            console.log(`값 ${valueIndex}: ${value}, 현재 MAX: ${maxValue}, 현재 MIN: ${minValue}`);
                        }
                    });
                }
            });
            
            // 최소값이 무한대인 경우 0으로 설정
            if (minValue === Infinity) {
                minValue = 0;
            }
            
            const result = {
                min: Math.floor(minValue),
                max: Math.ceil(maxValue)
            };
            
            console.log('자동 Y축 범위 계산 결과:', result);
            return result;
        }

        // 시간 라벨 업데이트
        function updateTimeLabels(chart, interval) {
            const intervalMinutes = parseInt(interval);
            const now = new Date();
            const labels = [];
            
            for (let i = 60; i >= 0; i -= intervalMinutes) {
                const time = new Date(now.getTime() - i * 60 * 1000);
                labels.push(time);
            }
            
            chart.data.labels = labels;
        }

        // 비교 데이터 추가
        function addComparisonData(chart, comparisonPeriod, color) {
            // 비교 기간에 따른 데이터 생성 (실제로는 서버에서 가져와야 함)
            const comparisonData = chart.data.labels.map(() => Math.random() * 30 + 40);
            
            chart.data.datasets.push({
                label: `비교 (${comparisonPeriod})`,
                data: comparisonData,
                borderColor: color,
                backgroundColor: color + '20',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                tension: 0.4,
                pointRadius: 0,
                pointHoverRadius: 4
            });
        }


        // 상세보기 모달 닫기
        function closeDetailViewModal() {
            // 상세보기 차트가 있다면 제거
            if (window.detailChart) {
                window.detailChart.destroy();
                window.detailChart = null;
            }
            
            document.getElementById('detailViewModal').style.display = 'none';
        }

        // 범례 설정 모달 열기
        function openLegendSettings(chartId) {
            document.getElementById('legendSettingsModal').style.display = 'block';
            
            // 현재 선택된 차트 ID 저장
            window.currentLegendChartId = chartId;
            
            // 차트 ID에서 차트 타입 추출 (예: stt-cpu -> stt)
            const chartType = chartId.split('-')[0];
            const engineNames = { 'stt': 'STT', 'tts': 'TTS', 'sv': 'SV' };
            const engineName = engineNames[chartType] || chartType.toUpperCase();
            
            // 모달 제목 업데이트
            document.getElementById('legendModalTitle').textContent = `${engineName} 서버 선택(범례) - ${chartId}`;
            
            renderLegendServerList(chartType, chartId);
        }

        // 범례 설정 모달 닫기
        function closeLegendSettingsModal() {
            document.getElementById('legendSettingsModal').style.display = 'none';
        }

        // 범례 서버 리스트 렌더링
        function renderLegendServerList(chartType = null, chartId = null) {
            const serverList = document.getElementById('legendServerList');
            const servers = getServersByChartType(chartType);
            
            // 차트별 범례 설정 로드
            const chartLegendSettings = getChartLegendSettings(chartId);
            
            serverList.innerHTML = servers.map(server => {
                const isSelected = chartLegendSettings.includes(server.id);
                return `
                    <div class="server-item" data-server="${server.id}" onclick="toggleLegendServerSelection('${server.id}')">
                        <input type="checkbox" id="legend-server-${server.id}" ${isSelected ? 'checked' : ''}>
                        <label for="legend-server-${server.id}">${server.name}</label>
                    </div>
                `;
            }).join('');
        }

        // 차트 타입별 서버 리스트 반환 (대시보드와 동일한 데이터 사용)
        function getServersByChartType(chartType) {
            const serverData = generateServerData();
            
            if (chartType === 'stt') {
                return serverData.stt.map(server => ({
                    id: server.id,
                    name: server.name,
                    type: 'stt',
                    selected: server.selected
                }));
            } else if (chartType === 'tts') {
                return serverData.tts.map(server => ({
                    id: server.id,
                    name: server.name,
                    type: 'tts',
                    selected: server.selected
                }));
            } else if (chartType === 'sv') {
                return serverData.sv.map(server => ({
                    id: server.id,
                    name: server.name,
                    type: 'sv',
                    selected: server.selected
                }));
            }
            
            // 모든 서버 반환 (차트 타입이 지정되지 않은 경우)
            return [
                ...serverData.stt.map(server => ({ ...server, type: 'stt' })),
                ...serverData.tts.map(server => ({ ...server, type: 'tts' })),
                ...serverData.sv.map(server => ({ ...server, type: 'sv' }))
            ];
        }

        // 범례 서버 선택 토글
        function toggleLegendServerSelection(serverId) {
            const serverItem = document.querySelector(`[data-server="${serverId}"]`);
            const checkbox = document.getElementById(`legend-server-${serverId}`);
            
            checkbox.checked = !checkbox.checked;
            serverItem.classList.toggle('selected', checkbox.checked);
        }

        // 범례 서버 전체 선택
        function selectAllLegendServers() {
            const checkboxes = document.querySelectorAll('#legendServerList input[type="checkbox"]');
            const serverItems = document.querySelectorAll('#legendServerList .server-item');
            
            checkboxes.forEach(checkbox => checkbox.checked = true);
            serverItems.forEach(item => item.classList.add('selected'));
        }

        // 범례 서버 전체 해제
        function deselectAllLegendServers() {
            const checkboxes = document.querySelectorAll('#legendServerList input[type="checkbox"]');
            const serverItems = document.querySelectorAll('#legendServerList .server-item');
            
            checkboxes.forEach(checkbox => checkbox.checked = false);
            serverItems.forEach(item => item.classList.remove('selected'));
        }

        // 차트별 범례 설정 저장소 초기화
        function initializeChartLegendSettings() {
            if (!window.chartLegendSettings) {
                window.chartLegendSettings = {};
            }
        }

        // 차트별 범례 설정 가져오기
        function getChartLegendSettings(chartId) {
            initializeChartLegendSettings();
            return window.chartLegendSettings[chartId] || [];
        }

        // 차트별 범례 설정 저장
        function setChartLegendSettings(chartId, selectedServers) {
            initializeChartLegendSettings();
            window.chartLegendSettings[chartId] = selectedServers;
        }

        // 범례 설정 저장
        function saveLegendSettings() {
            const currentChartId = window.currentLegendChartId;
            console.log('현재 차트 ID:', currentChartId);
            
            if (!currentChartId) {
                showNotification('차트 정보를 찾을 수 없습니다.');
                return;
            }

            const legendMode = document.querySelector('input[name="legendMode"]:checked').value;
            const selectedServers = Array.from(document.querySelectorAll('#legendServerList input[type="checkbox"]:checked'))
                .map(checkbox => checkbox.id.replace('legend-server-', ''));
            
            console.log('선택된 서버들:', selectedServers);
            
            // 현재 차트에만 범례 설정 저장
            setChartLegendSettings(currentChartId, selectedServers);
            
            // 현재 차트에만 범례 적용
            applyLegendToSpecificChart(currentChartId, selectedServers);
            
            closeLegendSettingsModal();
            showNotification(`${currentChartId} 차트의 범례 설정이 적용되었습니다. (${selectedServers.length}개 서버 선택)`);
        }

        // 특정 차트에만 범례 적용
        function applyLegendToSpecificChart(chartId, selectedServers) {
            // 특정 차트에만 선택된 서버 정보 적용
            console.log(`${chartId} 차트에 범례 적용:`, selectedServers);
            
            // 차트에 서버명 표시 로직 추가
            updateSpecificChartLegend(chartId, selectedServers);
        }

        // 범례를 차트에 적용 (기존 함수 - 호환성 유지)
        function applyLegendToCharts(selectedServers) {
            // 모든 차트에 선택된 서버 정보 적용
            window.selectedLegendServers = selectedServers;
            
            // 차트 업데이트 (실제 구현에서는 차트 라이브러리에 따라 다름)
            console.log('선택된 서버들:', selectedServers);
            
            // 차트에 서버명 표시 로직 추가
            updateChartLegends(selectedServers);
        }

        // 특정 차트 범례 업데이트
        function updateSpecificChartLegend(chartId, selectedServers) {
            // 특정 차트의 범례만 업데이트
            const chartElement = document.getElementById(`chart-container-${chartId}`);
            if (chartElement) {
                // 차트 컨테이너에 범례 정보 표시
                const legendContainer = chartElement.querySelector('.chart-legend') || createLegendContainer(chartElement);
                updateLegendDisplay(legendContainer, selectedServers);
            } else {
                console.error(`차트 컨테이너를 찾을 수 없습니다: chart-container-${chartId}`);
            }
        }

        // 범례 컨테이너 생성
        function createLegendContainer(chartElement) {
            const legendContainer = document.createElement('div');
            legendContainer.className = 'chart-legend';
            legendContainer.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(255, 255, 255, 0.9);
                padding: 8px;
                border-radius: 4px;
                font-size: 12px;
                z-index: 10;
            `;
            chartElement.style.position = 'relative';
            chartElement.appendChild(legendContainer);
            return legendContainer;
        }

        // 범례 표시 업데이트
        function updateLegendDisplay(legendContainer, selectedServers) {
            console.log('범례 표시 업데이트:', selectedServers);
            
            if (selectedServers.length === 0) {
                legendContainer.style.display = 'none';
                return;
            }

            legendContainer.style.display = 'block';
            legendContainer.innerHTML = selectedServers.map(serverId => `
                <div style="display: flex; align-items: center; margin: 2px 0;">
                    <div style="width: 12px; height: 12px; background: ${getServerColor(serverId)}; margin-right: 6px; border-radius: 2px;"></div>
                    <span>${serverId}</span>
                </div>
            `).join('');
            
            console.log('범례 HTML 생성됨:', legendContainer.innerHTML);
        }

        // 차트 범례 업데이트 (기존 함수 - 호환성 유지)
        function updateChartLegends(selectedServers) {
            // Chart.js를 사용한다면 다음과 같이 구현
            // 각 차트의 legend 설정을 업데이트
            const charts = Chart.instances || {};
            Object.values(charts).forEach(chart => {
                if (chart.options.plugins && chart.options.plugins.legend) {
                    chart.options.plugins.legend.display = true;
                    chart.options.plugins.legend.labels = {
                        generateLabels: function(chart) {
                            return selectedServers.map(serverId => ({
                                text: serverId,
                                fillStyle: getServerColor(serverId),
                                strokeStyle: getServerColor(serverId),
                                lineWidth: 2,
                                pointStyle: 'circle',
                                hidden: false
                            }));
                        }
                    };
                    chart.update();
                }
            });
        }

        // 서버별 색상 반환
        function getServerColor(serverId) {
            const colors = [
                '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
                '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1'
            ];
            const index = serverId.split('-').pop() % colors.length;
            return colors[index];
        }

        // 아코디언 토글
        function toggleAccordion(header) {
            const item = header.parentElement;
            const isActive = item.classList.contains('active');
            
            // 모든 아코디언 아이템 비활성화
            document.querySelectorAll('.accordion-item').forEach(accordionItem => {
                accordionItem.classList.remove('active');
            });
            
            // 클릭된 아이템만 활성화
            if (!isActive) {
                item.classList.add('active');
            }
        }

        // 사용자 선택 기간 설정 토글
        function toggleCustomPeriod() {
            const comparisonPeriod = document.getElementById('comparisonPeriod').value;
            const customPeriodSettings = document.getElementById('customPeriodSettings');
            
            if (comparisonPeriod === 'custom') {
                customPeriodSettings.style.display = 'block';
            } else {
                customPeriodSettings.style.display = 'none';
            }
        }

        // 실시간 모드 토글 (조회기간설정)
        function toggleRealtimeMode() {
            const customTimeSettings = document.getElementById('customTimeSettings');
            const realtimeBtn = event.target;
            
            if (customTimeSettings.style.display === 'none') {
                customTimeSettings.style.display = 'block';
                realtimeBtn.textContent = '기간 설정';
                realtimeBtn.style.background = '#6b7280';
            } else {
                customTimeSettings.style.display = 'none';
                realtimeBtn.textContent = '실시간';
                realtimeBtn.style.background = '#3b82f6';
            }
        }


        // 시간 범위 업데이트 (조회기간설정)
        function updateTimeRange() {
            const duration = document.getElementById('durationValue').value;
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            
            let displayText;
            
            if (startDate && startTime && endDate && endTime) {
                // 사용자 정의 시간 사용
                displayText = `${startDate} ${startTime} ~ ${endDate} ${endTime}`;
            } else {
                // 기본 시간 범위 계산
                const now = new Date();
                const end = new Date(now.getTime() + duration * 60 * 60 * 1000);
                
                const formatDateTime = (date) => {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    return `${year}/${month}/${day} ${hours}:${minutes}`;
                };
                
                displayText = `${formatDateTime(now)} ~ ${formatDateTime(end)}`;
            }
            
            document.getElementById('timeRangeDisplay').textContent = displayText;
        }

        // 날짜 입력 필드 초기화
        function initializeDateInputs() {
            const now = new Date();
            const end = new Date(now.getTime() + 60 * 60 * 1000); // 1시간 후
            
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            const formatTime = (date) => {
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${hours}:${minutes}`;
            };
            
            // 조회기간설정 날짜 초기화
            const startDateInput = document.getElementById('startDate');
            const startTimeInput = document.getElementById('startTime');
            const endDateInput = document.getElementById('endDate');
            const endTimeInput = document.getElementById('endTime');
            
            if (startDateInput) {
                startDateInput.value = formatDate(now);
                startTimeInput.value = formatTime(now);
                endDateInput.value = formatDate(end);
                endTimeInput.value = formatTime(end);
            }
            
            // 시계열 차트 날짜 초기화
            const customStartDateInput = document.getElementById('customStartDate');
            const customStartTimeInput = document.getElementById('customStartTime');
            const customEndDateInput = document.getElementById('customEndDate');
            const customEndTimeInput = document.getElementById('customEndTime');
            
            if (customStartDateInput) {
                customStartDateInput.value = formatDate(now);
                customStartTimeInput.value = formatTime(now);
                customEndDateInput.value = formatDate(end);
                customEndTimeInput.value = formatTime(end);
            }
        }

        // 시간 범위 업데이트 (시계열 차트)
        function updateCustomTimeRange() {
            const duration = document.getElementById('customDurationValue').value;
            const startDate = document.getElementById('customStartDate').value;
            const startTime = document.getElementById('customStartTime').value;
            const endDate = document.getElementById('customEndDate').value;
            const endTime = document.getElementById('customEndTime').value;
            
            let displayText;
            
            if (startDate && startTime && endDate && endTime) {
                // 사용자 정의 시간 사용
                displayText = `${startDate} ${startTime} ~ ${endDate} ${endTime}`;
            } else {
                // 기본 시간 범위 계산
                const now = new Date();
                const end = new Date(now.getTime() + duration * 60 * 60 * 1000);
                
                const formatDateTime = (date) => {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    return `${year}/${month}/${day} ${hours}:${minutes}`;
                };
                
                displayText = `${formatDateTime(now)} ~ ${formatDateTime(end)}`;
            }
            
            document.getElementById('customTimeRangeDisplay').textContent = displayText;
        }

        // 시간 범위 네비게이션 (조회기간설정)
        function navigateTimeRange(direction) {
            const duration = document.getElementById('durationValue');
            const currentValue = parseInt(duration.value);
            const newValue = Math.max(1, Math.min(24, currentValue + direction));
            duration.value = newValue;
            updateTimeRange();
        }

        // 시간 범위 네비게이션 (시계열 차트)
        function navigateCustomTimeRange(direction) {
            const duration = document.getElementById('customDurationValue');
            const currentValue = parseInt(duration.value);
            const newValue = Math.max(1, Math.min(24, currentValue + direction));
            duration.value = newValue;
            updateCustomTimeRange();
        }

        // 차트 종류 변경
        function changeChartType(chartId) {
            const chartType = document.getElementById(`chartType-${chartId}`).value;
            
            // 여기에 차트 종류를 변경하는 로직 추가
            console.log(`차트 ${chartId} 종류를 ${chartType}로 변경`);
            
            showNotification(`차트 종류가 ${chartType}로 변경되었습니다.`);
        }

        // MAX값 업데이트
        function updateMaxValue(chartId, value) {
            // 차트 내부의 MAX 값 업데이트 (실제 데이터 기반으로 자동 계산)
            updateChartMaxValue(chartId);
        }

        // 차트 내부 MAX 값 업데이트 (실제 데이터에서 최고값 자동 계산)
        function updateChartMaxValue(chartId) {
            const chartElement = document.getElementById(`chart-${chartId}`);
            if (chartElement && chartElement.chart) {
                const chart = chartElement.chart;
                if (chart.options.plugins.maxValueDisplay) {
                    // 실제 데이터에서 최고값을 다시 계산하도록 차트 업데이트
                    chart.update();
                }
            }
        }

        // 서버별 설정 모달 열기
        function openServerSettings() {
            const modal = document.getElementById('serverSettingsModal');
            const title = document.getElementById('serverSettingsTitle');
            const content = document.getElementById('serverSettingsContent');
            
            title.textContent = '서버별 설정';
            
            // 서버 데이터 생성
            const serverData = generateServerData();
            
            content.innerHTML = `
                <div class="server-settings-content">
                    ${Object.keys(serverData).map(serverType => `
                        <div class="server-type-section">
                            <div class="server-type-header">
                                <div class="server-type-icon ${serverType}">
                                    <i class="${getServerTypeIcon(serverType)}"></i>
                                </div>
                                <div class="server-type-title">${getServerTypeName(serverType)}</div>
                            </div>
                            <div class="server-list">
                                ${serverData[serverType].map(server => `
                                    <div class="server-item ${server.selected ? 'selected' : 'unselected'}">
                                        <div class="server-checkbox">
                                            <input type="checkbox" id="server-${server.id}" 
                                                   ${server.selected ? 'checked' : ''} 
                                                   onchange="toggleServerSelection('${server.id}')">
                                            <label for="server-${server.id}"></label>
                                        </div>
                                        <div class="server-info">
                                            <div class="server-status ${server.status}"></div>
                                            <div class="server-name">${server.name}</div>
                                        </div>
                                        <div class="server-actions">
                                            <button class="server-item-action-btn" onclick="configureServer('${server.id}')" title="설정">
                                                <i class="fas fa-cog"></i>
                                            </button>
                                            <button class="server-item-action-btn" onclick="viewServerDetails('${server.id}')" title="상세보기">
                                                <i class="fas fa-eye"></i>
                                            </button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div class="settings-buttons">
                    <button class="settings-btn-secondary" onclick="closeServerSettings()">닫기</button>
                    <button class="settings-btn-primary" onclick="applyServerSettings()">설정 적용</button>
                </div>
            `;
            
            modal.style.display = 'block';
            
            // 서버 카운트 초기화
            setTimeout(() => {
                updateServerCount();
            }, 100);
        }

        // 서버별 설정 모달 닫기
        function closeServerSettings() {
            document.getElementById('serverSettingsModal').style.display = 'none';
        }

        // 서버 선택 토글
        function toggleServerSelection(serverId) {
            const checkbox = document.getElementById(`server-${serverId}`);
            const serverItem = checkbox.closest('.server-item');
            
            // 체크박스 상태 토글
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                serverItem.classList.remove('unselected');
                serverItem.classList.add('selected');
            } else {
                serverItem.classList.remove('selected');
                serverItem.classList.add('unselected');
            }
            
            updateServerGroupCounts();
        }

        // 전체 서버 선택
        function selectAllServers() {
            const checkboxes = document.querySelectorAll('.server-list-scroll input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                const serverItem = checkbox.closest('.server-item');
                serverItem.classList.remove('unselected');
                serverItem.classList.add('selected');
            });
            updateServerGroupCounts();
        }

        // 전체 서버 해제
        function deselectAllServers() {
            const checkboxes = document.querySelectorAll('.server-list-scroll input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                const serverItem = checkbox.closest('.server-item');
                serverItem.classList.remove('selected');
                serverItem.classList.add('unselected');
            });
            updateServerGroupCounts();
        }

        // 서버 카운트 업데이트
        function updateServerCount() {
            const totalServers = document.querySelectorAll('#serverSettingsModal input[type="checkbox"]').length;
            const selectedServers = document.querySelectorAll('#serverSettingsModal input[type="checkbox"]:checked').length;
            
            const countElement = document.getElementById('serverCount');
            if (countElement) {
                countElement.textContent = `총 ${totalServers}개, 선택 ${selectedServers}개`;
            }
        }

        // 엔진 목록 토글
        function toggleEngineList() {
            const enginePanel = document.getElementById('cardOptionsPanel');
            const toggleBtn = document.getElementById('engineListToggle');
            const btnText = toggleBtn.querySelector('span');
            const btnIcon = toggleBtn.querySelector('i');
            
            if (enginePanel.style.display === 'none' || enginePanel.style.display === '') {
                // 보이기
                enginePanel.style.display = 'block';
                btnText.textContent = '닫기';
                btnIcon.className = 'fas fa-cogs';
            } else {
                // 숨기기
                enginePanel.style.display = 'none';
                btnText.textContent = '엔진';
                btnIcon.className = 'fas fa-eye';
            }
        }

        // 서버 목록 토글
        function toggleServerList() {
            const serverPanel = document.getElementById('serverSelectionPanel');
            const toggleBtn = document.getElementById('serverListToggle');
            const btnText = toggleBtn.querySelector('span');
            const btnIcon = toggleBtn.querySelector('i');
            
            if (serverPanel.style.display === 'none' || serverPanel.style.display === '') {
                // 보이기
                serverPanel.style.display = 'block';
                btnText.textContent = '닫기';
                btnIcon.className = 'fas fa-server';
            } else {
                // 숨기기
                serverPanel.style.display = 'none';
                btnText.textContent = '서버';
                btnIcon.className = 'fas fa-eye';
            }
        }

        // 서버 데이터 생성
        function generateServerData() {
            return {
                stt: [
                    { id: 'stt-001', name: 'o-pod-001', status: 'success', selected: true },
                    { id: 'stt-002', name: 'o-pod-002', status: 'success', selected: true },
                    { id: 'stt-003', name: 'o-pod-003', status: 'success', selected: true },
                    { id: 'stt-004', name: 'o-pod-004', status: 'success', selected: true },
                    { id: 'stt-005', name: 'o-pod-005', status: 'success', selected: true },
                    { id: 'stt-006', name: 'o-pod-006', status: 'success', selected: false },
                    { id: 'stt-007', name: 'o-pod-007', status: 'success', selected: false },
                    { id: 'stt-008', name: 'o-pod-008', status: 'success', selected: false },
                    { id: 'stt-009', name: 'o-pod-009', status: 'success', selected: false },
                    { id: 'stt-010', name: 'o-pod-010', status: 'success', selected: false },
                    { id: 'stt-011', name: 'o-pod-011', status: 'success', selected: false },
                    { id: 'stt-012', name: 'o-pod-012', status: 'success', selected: false },
                    { id: 'stt-013', name: 'o-pod-013', status: 'success', selected: false },
                    { id: 'stt-014', name: 'o-pod-014', status: 'success', selected: false },
                    { id: 'stt-015', name: 'o-pod-015', status: 'success', selected: false },
                    { id: 'stt-016', name: 'o-pod-016', status: 'success', selected: false },
                    { id: 'stt-017', name: 'o-pod-017', status: 'success', selected: false },
                    { id: 'stt-018', name: 'o-pod-018', status: 'success', selected: false },
                    { id: 'stt-019', name: 'o-pod-019', status: 'success', selected: false },
                    { id: 'stt-020', name: 'o-pod-020', status: 'success', selected: false },
                    { id: 'stt-021', name: 'o-pod-021', status: 'success', selected: false }
                ],
                tts: [
                    { id: 'tts-013', name: 'o-pod-013', status: 'success', selected: true },
                    { id: 'tts-014', name: 'o-pod-014', status: 'success', selected: true },
                    { id: 'tts-015', name: 'o-pod-015', status: 'success', selected: true },
                    { id: 'tts-016', name: 'o-pod-016', status: 'success', selected: true },
                    { id: 'tts-017', name: 'o-pod-017', status: 'success', selected: true },
                    { id: 'tts-018', name: 'o-pod-018', status: 'success', selected: true }
                ],
                sv: [
                    { id: 'sv-019', name: 'o-pod-019', status: 'success', selected: true },
                    { id: 'sv-020', name: 'o-pod-020', status: 'success', selected: true }
                ],
                common: [
                    { id: 'web-01', name: 'WEB-Server-01', status: 'success' },
                    { id: 'web-02', name: 'WEB-Server-02', status: 'success' },
                    { id: 'db-01', name: 'DB-Server-01', status: 'warning' },
                    { id: 'db-02', name: 'DB-Server-02', status: 'success' },
                    { id: 'cache-01', name: 'CACHE-Server-01', status: 'success' },
                    { id: 'monitor-01', name: 'MONITOR-Server-01', status: 'success' }
                ]
            };
        }

        // 서버 리스트 렌더링 (그룹화된 한줄)
        function renderServerGroups() {
            const serverData = generateServerData();
            const serverListContainer = document.getElementById('serverListContainer');
            
            // 그룹화된 서버 리스트 렌더링
            serverListContainer.innerHTML = `
                <!-- STT 서버 그룹 -->
                <div class="server-group-section">
                    <div class="server-group-label stt">
                        <i class="fas fa-microphone"></i>
                        <span>STT</span>
                    </div>
                    <div class="server-group-servers">
                        ${serverData.stt.map(server => `
                            <div class="server-item stt ${server.selected ? 'selected' : 'unselected'}" 
                                 onclick="toggleServerSelection('${server.id}')" 
                                 style="cursor: pointer;">
                                <div class="server-checkbox">
                                    <input type="checkbox" id="server-${server.id}" 
                                           ${server.selected ? 'checked' : ''} 
                                           style="pointer-events: none;">
                                    <label for="server-${server.id}"></label>
                                </div>
                                <div class="server-info">
                                    <div class="server-status ${server.status}"></div>
                                    <div class="server-name">${server.name}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <!-- TTS 서버 그룹 -->
                <div class="server-group-section">
                    <div class="server-group-label tts">
                        <i class="fas fa-volume-up"></i>
                        <span>TTS</span>
                    </div>
                    <div class="server-group-servers">
                        ${serverData.tts.map(server => `
                            <div class="server-item tts ${server.selected ? 'selected' : 'unselected'}" 
                                 onclick="toggleServerSelection('${server.id}')" 
                                 style="cursor: pointer;">
                                <div class="server-checkbox">
                                    <input type="checkbox" id="server-${server.id}" 
                                           ${server.selected ? 'checked' : ''} 
                                           style="pointer-events: none;">
                                    <label for="server-${server.id}"></label>
                                </div>
                                <div class="server-info">
                                    <div class="server-status ${server.status}"></div>
                                    <div class="server-name">${server.name}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <!-- SV 서버 그룹 -->
                <div class="server-group-section">
                    <div class="server-group-label sv">
                        <i class="fas fa-shield-alt"></i>
                        <span>SV</span>
                    </div>
                    <div class="server-group-servers">
                        ${serverData.sv.map(server => `
                            <div class="server-item sv ${server.selected ? 'selected' : 'unselected'}" 
                                 onclick="toggleServerSelection('${server.id}')" 
                                 style="cursor: pointer;">
                                <div class="server-checkbox">
                                    <input type="checkbox" id="server-${server.id}" 
                                           ${server.selected ? 'checked' : ''} 
                                           style="pointer-events: none;">
                                    <label for="server-${server.id}"></label>
                                </div>
                                <div class="server-info">
                                    <div class="server-status ${server.status}"></div>
                                    <div class="server-name">${server.name}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            // 서버 카운트 업데이트
            updateServerGroupCounts();
        }

        // 서버 카운트 업데이트
        function updateServerGroupCounts() {
            const allCheckboxes = document.querySelectorAll('.server-list-scroll input[type="checkbox"]');
            const selectedCheckboxes = document.querySelectorAll('.server-list-scroll input[type="checkbox"]:checked');
            
            // 전체 카운트 업데이트
            const totalServers = allCheckboxes.length;
            const totalSelected = selectedCheckboxes.length;
            document.getElementById('serverCount').textContent = `총 ${totalServers}개, 선택 ${totalSelected}개`;
        }

        // 서버 타입 아이콘 가져오기
        function getServerTypeIcon(serverType) {
            const icons = {
                stt: 'fas fa-microphone',
                tts: 'fas fa-volume-up',
                sv: 'fas fa-shield-alt',
                common: 'fas fa-server'
            };
            return icons[serverType] || 'fas fa-server';
        }

        // 서버 타입 이름 가져오기
        function getServerTypeName(serverType) {
            const names = {
                stt: 'STT 서버',
                tts: 'TTS 서버',
                sv: 'SV 서버',
                common: '공통 서버'
            };
            return names[serverType] || serverType.toUpperCase();
        }

        // 서버 설정
        function configureServer(serverId) {
            showNotification(`${serverId} 서버 설정을 열었습니다.`);
            // 여기에 개별 서버 설정 모달을 열거나 페이지로 이동하는 로직 추가
        }

        // 서버 상세보기
        function viewServerDetails(serverId) {
            showNotification(`${serverId} 서버 상세 정보를 표시합니다.`);
            // 여기에 서버 상세 정보 모달을 여는 로직 추가
        }

        // 서버 설정 적용
        function applyServerSettings() {
            showNotification('서버 설정이 적용되었습니다.');
            closeServerSettings();
        }

        // 대시보드 관리 모달 열기
        function openDashboardManagement() {
            console.log('🔄 대시보드 관리 모달 열기');
            
            const modal = document.getElementById('dashboardManagementModal');
            if (!modal) {
                console.error('❌ 대시보드 관리 모달을 찾을 수 없습니다');
                return;
            }
            
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            
            console.log('✅ 모달 표시 설정 완료');
            
            // 대시보드 목록 생성
            generateDashboardLists();
            
            // 모달이 열릴 때 선택 개수 초기화
            setTimeout(() => {
                updateSelectedCount();
                console.log('🔄 모달 열림 - 선택 개수 초기화');
            }, 100);
        }

        // 대시보드 관리 모달 닫기
        function closeDashboardManagement() {
            document.getElementById('dashboardManagementModal').style.display = 'none';
        }

        // 대시보드 목록 생성
        function generateDashboardLists() {
            const adminList = document.getElementById('adminDashboardList');
            const personalList = document.getElementById('personalDashboardList');
            
            // 기본 대시보드를 최상단으로 정렬
            const sortedAdminDashboards = sortDashboardsByDefault(dashboardData.admin);
            const sortedPersonalDashboards = sortDashboardsByDefault(dashboardData.personal);
            
            // 시리얼 넘버를 사용하여 대시보드 아이템 생성
            adminList.innerHTML = sortedAdminDashboards.map(dashboard => createDashboardItem(dashboard)).join('');
            personalList.innerHTML = sortedPersonalDashboards.map(dashboard => createDashboardItem(dashboard)).join('');
            
            updateSelectedCount();
        }

        // 기본 대시보드를 최상단으로 정렬하는 함수
        function sortDashboardsByDefault(dashboards) {
            return [...dashboards].sort((a, b) => {
                // 기본 대시보드가 먼저 오도록 정렬
                if (a.isDefault && !b.isDefault) return -1;
                if (!a.isDefault && b.isDefault) return 1;
                
                // 기본 대시보드가 아닌 경우 기존 순서 유지
                return 0;
            });
        }

        // 대시보드 아이템 생성
        function createDashboardItem(dashboard) {
            const isAdmin = dashboard.type === 'admin';
            const isDefault = dashboard.isDefault;
            
            // 시리얼 넘버를 사용한 대시보드 이름 생성
            const displayName = `No${dashboard.serialNumber} - ${dashboard.name}`;
            
            let actionButtons = '';
            if (isDefault) {
                actionButtons = '<div class="dashboard-status">기본 대시보드</div>';
            } else {
                actionButtons = `
                    <div class="dashboard-actions-hover">
                        <button class="action-btn modify-btn" onclick="modifyDashboard('${dashboard.id}')" title="수정">
                            <i class="fas fa-edit"></i>
                        </button>
                        ${isAdmin ? `<button class="action-btn default-btn" onclick="setAsDefault('${dashboard.id}')" title="기본 설정">
                            <i class="fas fa-star"></i>
                        </button>` : ''}
                    </div>
                `;
            }
            
            return `
                <div class="dashboard-item ${dashboard.selected ? 'selected' : ''}" ${isDefault ? '' : `onclick="toggleDashboardSelection('${dashboard.id}')"`}>
                    ${isDefault ? '' : `<input type="checkbox" class="dashboard-checkbox" ${dashboard.selected ? 'checked' : ''} onchange="toggleDashboardSelection('${dashboard.id}')">`}
                    <div class="dashboard-info">
                        <div class="dashboard-name">${displayName}</div>
                        <div class="dashboard-description">${dashboard.description}</div>
                    </div>
                    <div class="dashboard-actions">
                        ${actionButtons}
                    </div>
                </div>
            `;
        }

        // 대시보드 선택 토글
        function toggleDashboardSelection(dashboardId) {
            console.log('🔄 대시보드 선택 토글:', dashboardId);
            
            const item = document.querySelector(`[onclick="toggleDashboardSelection('${dashboardId}')"]`);
            if (!item) {
                console.error('❌ 대시보드 아이템을 찾을 수 없습니다:', dashboardId);
                return;
            }
            
            const checkbox = item.querySelector('.dashboard-checkbox');
            if (!checkbox) {
                console.error('❌ 체크박스를 찾을 수 없습니다:', dashboardId);
                return;
            }
            
            // 체크박스 상태 토글
            checkbox.checked = !checkbox.checked;
            item.classList.toggle('selected', checkbox.checked);
            
            console.log('✅ 체크박스 상태 변경:', checkbox.checked);
            
            // 선택 개수 업데이트
            updateSelectedCount();
        }

        // 선택된 대시보드 수 업데이트
        function updateSelectedCount() {
            console.log('🔄 선택 개수 업데이트 시작');
            
            const selectedCheckboxes = document.querySelectorAll('.dashboard-checkbox:checked');
            const selectedCount = selectedCheckboxes.length;
            const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
            const selectedCountSpan = document.getElementById('selectedCount');
            
            console.log('📊 선택된 체크박스 개수:', selectedCount);
            console.log('🔍 선택된 체크박스들:', selectedCheckboxes);
            
            if (!bulkDeleteBtn) {
                console.error('❌ 선택 삭제 버튼을 찾을 수 없습니다');
                return;
            }
            
            if (!selectedCountSpan) {
                console.error('❌ 선택 개수 표시 요소를 찾을 수 없습니다');
                return;
            }
            
            // 선택된 개수 업데이트
            selectedCountSpan.textContent = selectedCount;
            
            // 버튼 활성화/비활성화
            const shouldBeEnabled = selectedCount > 0;
            bulkDeleteBtn.disabled = !shouldBeEnabled;
            
            // 내보내기 버튼도 함께 활성화/비활성화
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.disabled = !shouldBeEnabled;
            }
            
            console.log(`📊 선택된 개수: ${selectedCount}, 버튼 활성화: ${shouldBeEnabled}`);
            
            // 시각적 피드백 강제 적용
            if (shouldBeEnabled) {
                bulkDeleteBtn.classList.add('active');
                bulkDeleteBtn.classList.remove('inactive');
                bulkDeleteBtn.style.background = '#dc2626';
                bulkDeleteBtn.style.borderColor = '#dc2626';
                bulkDeleteBtn.style.color = 'white';
                console.log('✅ 버튼 활성화 스타일 적용');
            } else {
                bulkDeleteBtn.classList.add('inactive');
                bulkDeleteBtn.classList.remove('active');
                bulkDeleteBtn.style.background = '#f3f4f6';
                bulkDeleteBtn.style.borderColor = '#e5e7eb';
                bulkDeleteBtn.style.color = '#9ca3af';
                console.log('❌ 버튼 비활성화 스타일 적용');
            }
        }

        // 대시보드 생성 섹션 토글
        function toggleCreateDashboard() {
            const content = document.getElementById('createDashboardContent');
            const toggle = document.getElementById('createDashboardToggle');
            
            content.classList.toggle('expanded');
            toggle.classList.toggle('rotated');
        }

        // 생성 폼으로 스크롤
        function scrollToCreateForm() {
            const createSection = document.getElementById('createDashboardContent');
            const toggle = document.getElementById('createDashboardToggle');
            
            // 생성 섹션을 먼저 열기
            createSection.classList.add('expanded');
            toggle.classList.add('rotated');
            
            // 생성 섹션으로 스크롤
            createSection.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
            
            console.log('생성 폼으로 스크롤 완료');
        }

        // 새 대시보드 생성
        function createNewDashboard() {
            const name = document.getElementById('newDashboardName').value;
            const description = document.getElementById('newDashboardDesc').value;
            const type = document.getElementById('newDashboardType').value;
            
            if (!name.trim()) {
                showNotification('대시보드 이름을 입력해주세요.');
                return;
            }
            
            // 새 대시보드 ID 생성
            const newId = type + '_' + Date.now();
            
            // 해당 타입의 다음 시리얼 넘버 계산
            const nextSerialNumber = getNextSerialNumber(type);
            
            // 새 대시보드 데이터 생성
            const newDashboard = {
                id: newId,
                serialNumber: nextSerialNumber,
                name: name,
                description: description,
                type: type,
                isDefault: false,
                selected: false
            };
            
            // 대시보드 데이터에 추가
            addDashboardData(newDashboard);
            
            console.log('✅ 새 대시보드 생성 완료:', newDashboard);
            
            // 새 대시보드는 빈 화면으로 설정 (모든 차트 숨김)
            initializeCardVisibility();
            
            // 성공 메시지 표시
            showNotification(`새 대시보드 "${name}"이 생성되었습니다.`);
            
            // 폼 초기화
            resetCreateDashboard();
            
            // 대시보드 관리 모달 닫기
            closeDashboardManagement();
            
            // 헤더의 대시보드 선택박스 업데이트
            updateDashboardSelector();
            
            // 새로 생성된 대시보드 선택
            selectDashboard(newId);
            
            // 차트 다시 렌더링 (빈 화면으로)
            renderCharts();
            
            console.log('🎨 새 대시보드 화면 렌더링 완료 (빈 화면)');
        }

        // 다음 시리얼 넘버 계산
        function getNextSerialNumber(type) {
            const dashboards = dashboardData[type];
            if (dashboards.length === 0) return 1;
            
            const maxSerialNumber = Math.max(...dashboards.map(d => d.serialNumber));
            return maxSerialNumber + 1;
        }

        // 대시보드 생성 폼 초기화
        function resetCreateDashboard() {
            document.getElementById('newDashboardName').value = '';
            document.getElementById('newDashboardDesc').value = '';
            document.getElementById('newDashboardType').value = 'admin';
        }

        // 대시보드 수정
        function modifyDashboard(dashboardId) {
            // 현재 대시보드 데이터 찾기
            const dashboard = findDashboardById(dashboardId);
            if (!dashboard) {
                showNotification('대시보드를 찾을 수 없습니다.');
                return;
            }
            
            // 수정 모달에 기존 데이터 설정
            document.getElementById('editDashboardName').value = dashboard.name;
            document.getElementById('editDashboardDesc').value = dashboard.description;
            document.getElementById('editDashboardType').value = dashboard.type;
            
            // 현재 수정 중인 대시보드 ID 저장
            window.currentEditDashboardId = dashboardId;
            
            // 대시보드 관리 모달 닫기
            closeDashboardManagement();
            
            // 수정 모달 열기
            const editModal = document.getElementById('editDashboardModal');
            editModal.style.display = 'flex';
            editModal.style.alignItems = 'center';
            editModal.style.justifyContent = 'center';
        }

        // 수정 모달 닫기
        function closeEditDashboard() {
            document.getElementById('editDashboardModal').style.display = 'none';
            // 대시보드 관리 모달 다시 열기
            openDashboardManagement();
        }

        // 수정 완료
        function confirmEditDashboard() {
            const name = document.getElementById('editDashboardName').value;
            const description = document.getElementById('editDashboardDesc').value;
            const type = document.getElementById('editDashboardType').value;
            
            if (!name.trim()) {
                showNotification('대시보드 이름을 입력해주세요.');
                return;
            }
            
            // 대시보드 데이터 업데이트
            updateDashboardData(window.currentEditDashboardId, {
                name: name,
                description: description,
                type: type
            });
            
            showNotification('대시보드가 수정되었습니다.');
            closeEditDashboard();
        }

        // 개별 삭제 함수는 제거됨 - 선택 삭제 사용

        // 삭제 확인 모달 닫기
        function closeDeleteConfirm() {
            document.getElementById('deleteConfirmModal').style.display = 'none';
            // 대시보드 관리 모달 다시 열기
            openDashboardManagement();
        }

        // 삭제 확인
        function confirmDeleteDashboard() {
            const dashboardId = window.currentDeleteDashboardId;
            if (!dashboardId) {
                showNotification('삭제할 대시보드를 찾을 수 없습니다.');
                return;
            }
            
            // 대시보드 데이터에서 삭제
            removeDashboardData(dashboardId);
            
            showNotification('대시보드가 삭제되었습니다.');
            closeDeleteConfirm();
        }

        // 기본 대시보드 설정
        function setAsDefault(dashboardId) {
            const dashboard = findDashboardById(dashboardId);
            if (!dashboard) {
                showNotification('대시보드를 찾을 수 없습니다.');
                return;
            }
            
            if (dashboard.type !== 'admin') {
                showNotification('관리자 대시보드만 기본으로 설정할 수 있습니다.');
                return;
            }
            
            // 모든 관리자 대시보드의 기본 설정 해제
            resetAllAdminDefaults();
            
            // 선택된 대시보드를 기본으로 설정
            setDashboardAsDefault(dashboardId);
            
            showNotification('기본 대시보드로 설정되었습니다.');
            
            // 목록 새로고침 (기본 대시보드가 최상단으로 이동)
            generateDashboardLists();
        }

        // 선택된 대시보드 내보내기
        function exportSelectedDashboards() {
            const selectedDashboards = Array.from(document.querySelectorAll('.dashboard-item.selected')).map(item => {
                const name = item.querySelector('.dashboard-name').textContent;
                const description = item.querySelector('.dashboard-description').textContent;
                return { name, description };
            });
            
            if (selectedDashboards.length === 0) {
                showNotification('내보낼 대시보드를 선택해주세요.');
                return;
            }
            
            console.log('선택된 대시보드 내보내기:', selectedDashboards);
            
            // 윈도우 시스템 폴더 지정 창 띄우기
            try {
                const data = JSON.stringify(selectedDashboards, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // 사용자 상호작용이 필요한 경우를 대비한 방법
                const link = document.createElement('a');
                link.href = url;
                link.download = `dashboard_export_${new Date().toISOString().slice(0, 10)}.json`;
                link.target = '_blank';
                
                // 스타일 설정
                link.style.display = 'none';
                link.style.visibility = 'hidden';
                
                // DOM에 추가
                document.body.appendChild(link);
                
                // 사용자 상호작용 시뮬레이션
                const event = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true,
                    button: 0
                });
                
                // 이벤트 발생
                link.dispatchEvent(event);
                
                // 정리
                setTimeout(() => {
                    if (document.body.contains(link)) {
                        document.body.removeChild(link);
                    }
                    URL.revokeObjectURL(url);
                }, 1000);
                
                console.log('다운로드 시작:', link.download);
                console.log('URL:', url);
            } catch (error) {
                console.error('다운로드 오류:', error);
                showNotification('다운로드 중 오류가 발생했습니다.', 'error');
            }
            
            showNotification(`${selectedDashboards.length}개 대시보드를 내보냈습니다.`);
        }

        // 대시보드 가져오기
        function importDashboardData() {
            // 가져오기 모달 열기
            const importModal = document.getElementById('importModal');
            const destinationSection = document.getElementById('importDestinationSection');
            
            console.log('가져오기 모달 열기 시도');
            console.log('importModal:', importModal);
            console.log('destinationSection:', destinationSection);
            
            // 관리자 권한 확인 (실제로는 서버에서 확인해야 함)
            const isAdmin = true; // 임시로 관리자로 설정
            console.log('관리자 권한 확인:', isAdmin);
            
            if (isAdmin) {
                destinationSection.style.display = 'block';
                console.log('관리자 권한 확인됨 - 대상 선택 UI 표시');
            } else {
                destinationSection.style.display = 'none';
                console.log('일반 사용자 - 대상 선택 UI 숨김');
            }
            
            // 모달 표시
            importModal.style.display = 'flex';
            importModal.classList.add('show');
            console.log('가져오기 모달 표시 완료');
        }

        // 파일 업로드 처리
        function handleDashboardFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                console.log('대시보드 파일 업로드:', file.name);
                showNotification('대시보드 파일을 가져왔습니다.');
            }
        }

        // 선택된 대시보드 삭제
        function deleteSelectedDashboards() {
            console.log('🗑️ 선택 삭제 함수 호출');
            
            // 체크박스가 선택된 아이템들 찾기
            const selectedCheckboxes = document.querySelectorAll('.dashboard-checkbox:checked');
            const selectedCount = selectedCheckboxes.length;
            
            console.log('✅ 선택된 체크박스 개수:', selectedCount);
            
            if (selectedCount === 0) {
                showNotification('❌ 삭제할 대시보드를 선택해주세요.');
                return;
            }
            
            // 선택된 대시보드들의 ID 수집
            const selectedIds = Array.from(selectedCheckboxes).map(checkbox => {
                const item = checkbox.closest('.dashboard-item');
                const onclick = item.getAttribute('onclick');
                const match = onclick.match(/toggleDashboardSelection\('([^']+)'\)/);
                return match ? match[1] : null;
            }).filter(id => id !== null);
            
            console.log('📋 선택된 대시보드 ID들:', selectedIds);
            
            // 기본 대시보드가 선택되었는지 확인
            const hasDefaultDashboard = selectedIds.some(dashboardId => {
                const dashboard = findDashboardById(dashboardId);
                return dashboard && dashboard.isDefault;
            });
            
            if (hasDefaultDashboard) {
                showNotification('⚠️ 기본 대시보드는 삭제할 수 없습니다.');
                return;
            }
            
            // 삭제 확인
            const confirmMessage = `정말로 선택된 ${selectedCount}개 대시보드를 삭제하시겠습니까?\n\n삭제된 대시보드는 복구할 수 없습니다.`;
            
            if (confirm(confirmMessage)) {
                console.log('🔥 삭제 시작...');
                
                // 각 대시보드 삭제
                selectedIds.forEach((dashboardId, index) => {
                    console.log(`🗑️ ${index + 1}/${selectedIds.length} 삭제 중: ${dashboardId}`);
                    removeDashboardData(dashboardId);
                });
                
                showNotification(`✅ ${selectedCount}개 대시보드가 성공적으로 삭제되었습니다.`);
                generateDashboardLists(); // 목록 새로고침
                
                console.log('✅ 삭제 완료!');
            } else {
                console.log('❌ 삭제 취소됨');
            }
        }

        // 대시보드 데이터 관리 함수들
        let dashboardData = {
            admin: [
                { id: 'admin1', serialNumber: 1, name: '시스템 전체 모니터링', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'admin', isDefault: true, selected: false },
                { id: 'admin2', serialNumber: 2, name: '서버 성능 분석', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'admin', isDefault: false, selected: true },
                { id: 'admin3', serialNumber: 3, name: '네트워크 트래픽', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'admin', isDefault: false, selected: false },
                { id: 'admin4', serialNumber: 4, name: '보안 모니터링', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'admin', isDefault: false, selected: false }
            ],
            personal: [
                { id: 'personal1', serialNumber: 1, name: '내 작업 모니터링', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'personal', isDefault: false, selected: true },
                { id: 'personal2', serialNumber: 2, name: '개발 환경 상태', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'personal', isDefault: false, selected: true },
                { id: 'personal3', serialNumber: 3, name: '테스트 서버', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'personal', isDefault: false, selected: false },
                { id: 'personal4', serialNumber: 4, name: '개인 프로젝트', description: '메모 내용 일부 표시 width의 1/2 넘어갈 시 말줄임..', type: 'personal', isDefault: false, selected: false }
            ]
        };

        // 대시보드 ID로 찾기
        function findDashboardById(dashboardId) {
            for (const type in dashboardData) {
                const dashboard = dashboardData[type].find(d => d.id === dashboardId);
                if (dashboard) return dashboard;
            }
            return null;
        }

        // 대시보드 데이터 추가
        function addDashboardData(dashboard) {
            dashboardData[dashboard.type].push(dashboard);
        }

        // 대시보드 데이터 업데이트
        function updateDashboardData(dashboardId, updates) {
            const dashboard = findDashboardById(dashboardId);
            if (dashboard) {
                Object.assign(dashboard, updates);
            }
        }

        // 대시보드 데이터 삭제
        function removeDashboardData(dashboardId) {
            for (const type in dashboardData) {
                const index = dashboardData[type].findIndex(d => d.id === dashboardId);
                if (index !== -1) {
                    dashboardData[type].splice(index, 1);
                    break;
                }
            }
        }

        // 모든 관리자 대시보드 기본 설정 해제
        function resetAllAdminDefaults() {
            dashboardData.admin.forEach(dashboard => {
                dashboard.isDefault = false;
            });
        }

        // 대시보드를 기본으로 설정
        function setDashboardAsDefault(dashboardId) {
            const dashboard = findDashboardById(dashboardId);
            if (dashboard) {
                dashboard.isDefault = true;
            }
        }

        // 헤더 대시보드 선택박스 업데이트
        function updateDashboardSelector() {
            console.log('🔄 대시보드 선택박스 업데이트');
            
            const dashboardSelect = document.getElementById('dashboardSelect');
            if (!dashboardSelect) {
                console.error('❌ 대시보드 선택박스를 찾을 수 없습니다');
                return;
            }
            
            // 현재 선택된 대시보드 유형 확인
            const publicBtn = document.getElementById('publicTypeBtn');
            const personalBtn = document.getElementById('personalTypeBtn');
            const currentType = publicBtn?.classList.contains('active') ? 'admin' : 'personal';
            
            console.log('📊 현재 대시보드 유형:', currentType);
            
            // 해당 유형의 대시보드 목록 가져오기
            const dashboards = dashboardData[currentType] || [];
            console.log(`📋 ${currentType} 대시보드 목록:`, dashboards);
            
            // 선택박스 옵션 업데이트
            dashboardSelect.innerHTML = '';
            
            dashboards.forEach((dashboard, index) => {
                const option = document.createElement('option');
                option.value = dashboard.id;
                option.textContent = `${dashboard.serialNumber}. ${dashboard.name}`;
                
                // 기본 대시보드인 경우 선택
                if (dashboard.isDefault) {
                    option.selected = true;
                }
                
                dashboardSelect.appendChild(option);
            });
            
            console.log('✅ 대시보드 선택박스 업데이트 완료');
        }

        // 대시보드 선택
        function selectDashboard(dashboardId) {
            console.log('🎯 대시보드 선택:', dashboardId);
            
            // 선택된 대시보드로 전환
            if (dashboardId) {
                // 대시보드 전환 로직
                console.log('✅ 대시보드 전환 완료:', dashboardId);
                
                // 성공 메시지 표시
                showNotification(`대시보드가 "${dashboardId}"로 전환되었습니다.`);
            }
        }

        // 대시보드 체크박스 그룹 생성
        function generateDashboardRadioGroup() {
            const radioGroup = document.getElementById('dashboardRadioGroup');
            const dashboards = Object.keys(dashboardConfigs);
            
            // 대시보드를 유형별로 분류
            const adminDashboards = dashboards.filter(id => dashboardConfigs[id].type === 'admin');
            const personalDashboards = dashboards.filter(id => dashboardConfigs[id].type === 'personal');
            const otherDashboards = dashboards.filter(id => !dashboardConfigs[id].type || (dashboardConfigs[id].type !== 'admin' && dashboardConfigs[id].type !== 'personal'));
            
            let html = '';
            
            // 관리자 대시보드 섹션
            if (adminDashboards.length > 0) {
                html += `
                    <div class="dashboard-type-group">
                        <div class="dashboard-type-header">
                            <div class="dashboard-type-icon admin">
                                <i class="fas fa-crown"></i>
                            </div>
                            <div class="dashboard-type-title">관리자 대시보드</div>
                        </div>
                        <div class="dashboard-type-list">
                            ${adminDashboards.map(id => {
                                const config = dashboardConfigs[id];
                                const isSelected = currentDashboard === id;
                                return `
                                    <div class="dashboard-checkbox-item ${isSelected ? 'selected' : ''}">
                                        <input type="checkbox" name="dashboardSelect" value="${id}" ${isSelected ? 'checked' : ''} onchange="toggleDashboardSelection('${id}')">
                                        <div class="dashboard-checkbox-info">
                                            <div class="dashboard-checkbox-name">${config.name}</div>
                                            <div class="dashboard-checkbox-desc">${config.description}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
                    
            // 개인 대시보드 섹션
            if (personalDashboards.length > 0) {
                html += `
                    <div class="dashboard-type-group">
                        <div class="dashboard-type-header">
                            <div class="dashboard-type-icon personal">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="dashboard-type-title">개인 대시보드</div>
                        </div>
                        <div class="dashboard-type-list">
                            ${personalDashboards.map(id => {
                                const config = dashboardConfigs[id];
                                const isSelected = currentDashboard === id;
                                return `
                                    <div class="dashboard-checkbox-item ${isSelected ? 'selected' : ''}">
                                        <input type="checkbox" name="dashboardSelect" value="${id}" ${isSelected ? 'checked' : ''} onchange="toggleDashboardSelection('${id}')">
                                        <div class="dashboard-checkbox-info">
                                            <div class="dashboard-checkbox-name">${config.name}</div>
                                            <div class="dashboard-checkbox-desc">${config.description}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            // 기타 대시보드 섹션
            if (otherDashboards.length > 0) {
                html += `
                    <div class="dashboard-type-group">
                        <div class="dashboard-type-header">
                            <div class="dashboard-type-icon default">
                                <i class="fas fa-th-large"></i>
                            </div>
                            <div class="dashboard-type-title">기타 대시보드</div>
                        </div>
                        <div class="dashboard-type-list">
                            ${otherDashboards.map(id => {
                                const config = dashboardConfigs[id];
                                const isSelected = currentDashboard === id;
                                return `
                                    <div class="dashboard-checkbox-item ${isSelected ? 'selected' : ''}">
                                        <input type="checkbox" name="dashboardSelect" value="${id}" ${isSelected ? 'checked' : ''} onchange="toggleDashboardSelection('${id}')">
                                        <div class="dashboard-checkbox-info">
                                            <div class="dashboard-checkbox-name">${config.name}</div>
                                            <div class="dashboard-checkbox-desc">${config.description}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            radioGroup.innerHTML = html;
            
            // 선택된 항목 수 업데이트
            updateSelectedCount();
        }

        // 대시보드 목록 생성
        function generateDashboardList() {
            const dashboardList = document.getElementById('dashboardList');
            const dashboards = Object.keys(dashboardConfigs);
            
            dashboardList.innerHTML = dashboards.map(id => {
                const config = dashboardConfigs[id];
                return `
                    <div class="dashboard-list-item">
                        <div class="dashboard-list-info">
                            <div class="dashboard-list-name">${config.name}</div>
                            <div class="dashboard-list-desc">${config.description}</div>
                </div>
                        <div class="dashboard-list-actions">
                            <button class="dashboard-list-btn delete-btn" onclick="deleteDashboard('${id}')" title="삭제">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                </div>
            `;
            }).join('');
        }

        // 대시보드 삭제 함수
        function deleteDashboard(dashboardId) {
            const config = dashboardConfigs[dashboardId];
            if (!config) {
                showNotification('대시보드를 찾을 수 없습니다.', 'error');
                return;
            }

            // 삭제 확인 모달에 대시보드 이름 표시
            document.getElementById('deleteDashboardName').textContent = config.name;
            
            // 삭제할 대시보드 ID를 전역 변수에 저장
            window.dashboardToDelete = dashboardId;
            
            // 삭제 확인 모달 표시
            document.getElementById('deleteConfirmModal').style.display = 'block';
        }

        // 삭제 확인 모달 닫기
        function closeDeleteConfirm() {
            document.getElementById('deleteConfirmModal').style.display = 'none';
            window.dashboardToDelete = null;
            window.dashboardsToDelete = null;
        }

        // 대시보드 삭제 확인
        function confirmDeleteDashboard() {
            // 단일 삭제와 다중 삭제 모두 지원
            const dashboardIds = window.dashboardsToDelete || (window.dashboardToDelete ? [window.dashboardToDelete] : []);
            
            if (dashboardIds.length === 0) {
                showNotification('삭제할 대시보드가 선택되지 않았습니다.', 'error');
                return;
            }

            try {
                let deletedCount = 0;
                let currentDashboardDeleted = false;
                
                // 선택된 대시보드들 삭제
                dashboardIds.forEach(dashboardId => {
                    if (dashboardConfigs[dashboardId]) {
                        delete dashboardConfigs[dashboardId];
                        deletedCount++;
                        
                        // 현재 대시보드가 삭제된 경우 플래그 설정
                        if (currentDashboardId === dashboardId) {
                            currentDashboardDeleted = true;
                        }
                    }
                });
                
                // 현재 대시보드가 삭제된 경우 다른 대시보드로 전환
                if (currentDashboardDeleted) {
                    const remainingDashboards = Object.keys(dashboardConfigs);
                    if (remainingDashboards.length > 0) {
                        switchDashboard(remainingDashboards[0]);
                    } else {
                        // 대시보드가 없으면 기본 대시보드 생성
                        createDefaultDashboard();
                    }
                }

                // UI 업데이트
                generateDashboardRadioGroup();
                generateDashboardList();
                
                // 삭제 확인 모달 닫기
                closeDeleteConfirm();
                
                // 전역 변수 초기화
                window.dashboardsToDelete = null;
                window.dashboardToDelete = null;
                
                showNotification(`${deletedCount}개의 대시보드가 성공적으로 삭제되었습니다.`);
            } catch (error) {
                console.error('대시보드 삭제 오류:', error);
                showNotification('대시보드 삭제 중 오류가 발생했습니다.', 'error');
            }
        }

        // 기본 대시보드 생성 (대시보드가 모두 삭제된 경우)
        function createDefaultDashboard() {
            const defaultId = 'default';
            dashboardConfigs[defaultId] = {
                name: '기본 대시보드',
                description: '새로 생성된 기본 대시보드입니다.',
                charts: ['cpu', 'memory', 'network', 'disk']
            };
            currentDashboardId = defaultId;
            renderCharts();
        }

        // 선택 삭제 함수
        function bulkDeleteDashboards() {
            const selectedCheckboxes = document.querySelectorAll('input[name="dashboardSelect"]:checked');
            const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                showNotification('삭제할 대시보드를 선택해주세요.', 'error');
                return;
            }

            // 삭제 확인 모달에 선택된 대시보드 이름들 표시
            const selectedNames = selectedIds.map(id => dashboardConfigs[id]?.name).filter(Boolean);
            document.getElementById('deleteDashboardName').textContent = selectedNames.join(', ');
            
            // 삭제할 대시보드 ID들을 전역 변수에 저장
            window.dashboardsToDelete = selectedIds;
            
            // 삭제 확인 모달 표시
            document.getElementById('deleteConfirmModal').style.display = 'block';
        }

        // 라디오 버튼 선택 처리
        function selectDashboardRadio(dashboardId) {
            // 모든 라디오 아이템에서 selected 클래스 제거
            document.querySelectorAll('.dashboard-radio-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // 선택된 아이템에 selected 클래스 추가
            event.currentTarget.classList.add('selected');
            
            // 라디오 버튼 체크
            document.querySelector(`input[value="${dashboardId}"]`).checked = true;
            
            // 현재 대시보드 업데이트
            currentDashboard = dashboardId;
        }

        // 선택된 대시보드 내보내기
        function exportSelectedDashboard() {
            const selectedRadio = document.querySelector('input[name="dashboardSelect"]:checked');
            if (!selectedRadio) {
                showNotification('내보낼 대시보드를 선택해주세요.', 'error');
                return;
            }
            
            const dashboardId = selectedRadio.value;
            const config = dashboardConfigs[dashboardId];
            
            try {
                const dashboardData = {
                    metadata: {
                        title: config.name,
                        version: "1.0",
                        exportDate: new Date().toISOString(),
                        mode: currentMode,
                        dashboardId: dashboardId
                    },
                    settings: {
                        globalTimeRange: document.getElementById('globalTimeRange').value,
                        xAxisRangeMode: document.getElementById('xAxisRangeMode').value,
                        dataMode: document.getElementById('dataMode').value
                    },
                    layout: {
                        chartOrder: Array.from(document.getElementById('chartsGrid').children).map(card => card.id),
                        cardSizes: Array.from(document.querySelectorAll('.chart-card')).map(card => ({
                            id: card.id,
                            width: card.style.width || 'auto',
                            height: card.style.height || 'auto'
                        }))
                    },
                    charts: Object.keys(charts).map(chartId => ({
                        id: chartId,
                        type: charts[chartId].config.type,
                        visible: document.getElementById(`card-${chartId}`).style.display !== 'none'
                    }))
                };

                const dataStr = JSON.stringify(dashboardData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `${config.name.replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showNotification(`${config.name} 대시보드가 성공적으로 내보내기되었습니다.`);
            } catch (error) {
                console.error('내보내기 오류:', error);
                showNotification('내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        // 대시보드 데이터 가져오기
        function importDashboardData() {
            document.getElementById('dashboardFileInput').click();
        }

        // 파일 업로드 처리
        function handleDashboardFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.toLowerCase().endsWith('.json')) {
                showNotification('JSON 파일만 업로드할 수 있습니다.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const dashboardData = JSON.parse(e.target.result);
                    restoreDashboardFromJson(dashboardData);
                    showNotification('대시보드가 성공적으로 가져오기되었습니다.');
            closeDashboardManagement();
                } catch (error) {
                    console.error('JSON 파싱 오류:', error);
                    showNotification('유효하지 않은 JSON 파일입니다.', 'error');
                }
            };
            reader.readAsText(file);
        }



        // 새 대시보드 생성 모달 닫기
        function closeCreateDashboard() {
            document.getElementById('createDashboardModal').style.display = 'none';
        }

        // 새 대시보드 생성 확인
        function confirmCreateDashboard() {
            const name = document.getElementById('newDashboardName').value.trim();
            const description = document.getElementById('newDashboardDesc').value.trim();
            const type = document.getElementById('newDashboardType').value;
            
            if (!name) {
                showNotification('대시보드 이름을 입력해주세요.', 'error');
                document.getElementById('newDashboardName').focus();
                return;
            }
            
            // 이름 중복 확인
            const existingNames = Object.values(dashboardConfigs).map(config => config.name.toLowerCase());
            if (existingNames.includes(name.toLowerCase())) {
                showNotification('이미 존재하는 대시보드 이름입니다.', 'error');
                document.getElementById('newDashboardName').focus();
                return;
            }
            
            try {
                // 새 대시보드 ID 생성
                const newId = 'dashboard_' + Date.now();
                
                // 새 대시보드 설정 생성
                dashboardConfigs[newId] = {
                    name: name,
                    description: description || '새로 생성된 대시보드입니다.',
                    type: type,
                    charts: ['cpu', 'memory', 'network', 'disk'] // 기본 차트들
                };
                
                // 새 대시보드로 전환
                currentDashboardId = newId;
                switchDashboard(newId);
                
                // UI 업데이트
                generateDashboardRadioGroup();
                generateDashboardList();
                
                // 모달들 닫기
                closeCreateDashboard();
                closeDashboardManagement();
                
                showNotification(`"${name}" 대시보드가 생성되었습니다.`);
            } catch (error) {
                console.error('대시보드 생성 오류:', error);
                showNotification('대시보드 생성 중 오류가 발생했습니다.', 'error');
            }
        }

        // 수정 모드에서 변경사항 적용
        function applyEditChanges() {
            // 현재 카드 표시 상태를 저장
            const currentVisibility = { ...cardVisibility };
            
            // 변경사항을 로컬 스토리지에 저장 (선택사항)
            localStorage.setItem('cardVisibility', JSON.stringify(currentVisibility));
            
            // 수정 모드에서 조회 모드로 전환
            switchMode('view');
            
            showNotification('변경사항이 적용되었습니다.');
        }

        // 수정 모드에서 변경사항 초기화
        function resetEditChanges() {
            // 원래 상태로 복원
            initializeCardVisibility();
            createOptionsPanel();
            renderCharts();
            
            showNotification('변경사항이 초기화되었습니다.');
        }

        // 차트 설정 적용 (기존 함수)
        function applyChartSettingsOld(chartId) {
            const config = chartConfigs[chartId];
            if (!config) return;
            
            // 차트 타입 변경
            const chartType = document.getElementById(`chartType-${chartId}`).value;
            if (charts[chartId] && chartType !== 'line') {
                // 차트 타입 변경 로직 (현재는 라인 차트만 지원)
                showNotification('차트 타입 변경 기능은 준비 중입니다.');
            }
            
            // 시간 범위 설정
            const timeRange = document.getElementById(`timeRange-${chartId}`).value;
            if (timeRange) {
                updateChartTimeRange(chartId, timeRange);
            } else {
                updateChartTimeRange(chartId, '');
            }
            
            // X축 범위 설정
            const xAxisMin = document.getElementById(`xAxisMin-${chartId}`).value;
            const xAxisMax = document.getElementById(`xAxisMax-${chartId}`).value;
            
            individualXAxisRanges[chartId] = {
                min: xAxisMin ? parseFloat(xAxisMin) : undefined,
                max: xAxisMax ? parseFloat(xAxisMax) : undefined
            };
            
            if (charts[chartId]) {
                charts[chartId].options.scales.x.min = individualXAxisRanges[chartId].min;
                charts[chartId].options.scales.x.max = individualXAxisRanges[chartId].max;
                charts[chartId].update();
            }
            
            // 임계치 설정
            const warningThreshold = parseFloat(document.getElementById(`warningThreshold-${chartId}`).value);
            const criticalThreshold = parseFloat(document.getElementById(`criticalThreshold-${chartId}`).value);
            
            thresholds[chartId] = {
                warning: warningThreshold,
                critical: criticalThreshold
            };
            
            closeChartSettings();
            showNotification(`${config.name} 설정이 적용되었습니다.`);
        }

        // 차트를 SVG로 내보내기
        function exportChartAsSVG(chartId) {
            const config = chartConfigs[chartId];
            if (!config) return;
            
            const chart = charts[chartId];
            if (!chart) {
                showNotification('차트를 찾을 수 없습니다.');
                return;
            }
            
            try {
                // Chart.js에서 SVG 데이터 가져오기
                const canvas = document.getElementById(`chart-${chartId}`);
                if (!canvas) {
                    showNotification('차트 캔버스를 찾을 수 없습니다.');
                    return;
                }
                
                // Canvas를 SVG로 변환
                const svgData = canvasToSVG(canvas, config);
                
                // SVG 파일 다운로드
                downloadSVG(svgData, `${config.name}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.svg`);
                
                showNotification(`${config.name} 차트가 SVG 파일로 저장되었습니다.`);
            } catch (error) {
                console.error('SVG 내보내기 오류:', error);
                showNotification('SVG 내보내기 중 오류가 발생했습니다.');
            }
        }

        // Canvas를 SVG로 변환
        function canvasToSVG(canvas, config) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // SVG 헤더 생성
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
            
            // 배경
            svg += `<rect width="100%" height="100%" fill="white"/>`;
            
            // 차트 제목
            svg += `<text x="20" y="30" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#212529">${config.name}</text>`;
            
            // 차트 데이터를 SVG로 변환
            const chartData = chart.data;
            const datasets = chartData.datasets;
            
            datasets.forEach((dataset, datasetIndex) => {
                const color = dataset.borderColor || dataset.backgroundColor;
                const points = dataset.data;
                
                if (points && points.length > 0) {
                    // 라인 그리기
                    let pathData = '';
                    points.forEach((point, index) => {
                        if (point !== null && point !== undefined) {
                            const x = 50 + (index * (width - 100) / (points.length - 1));
                            const y = height - 80 - (point * (height - 120) / config.max);
                            
                            if (index === 0) {
                                pathData += `M ${x} ${y}`;
                            } else {
                                pathData += ` L ${x} ${y}`;
                            }
                        }
                    });
                    
                    if (pathData) {
                        svg += `<path d="${pathData}" stroke="${color}" stroke-width="2" fill="none"/>`;
                    }
                    
                    // 포인트 그리기
                    points.forEach((point, index) => {
                        if (point !== null && point !== undefined) {
                            const x = 50 + (index * (width - 100) / (points.length - 1));
                            const y = height - 80 - (point * (height - 120) / config.max);
                            
                            svg += `<circle cx="${x}" cy="${y}" r="3" fill="${color}"/>`;
                        }
                    });
                }
            });
            
            // Y축 그리드 라인
            for (let i = 0; i <= 5; i++) {
                const y = 60 + (i * (height - 120) / 5);
                const value = Math.round((config.max / 5) * (5 - i));
                
                svg += `<line x1="50" y1="${y}" x2="${width - 50}" y2="${y}" stroke="#e9ecef" stroke-width="1"/>`;
                svg += `<text x="10" y="${y + 5}" font-family="Arial, sans-serif" font-size="10" fill="#6c757d" text-anchor="end">${value}${config.unit}</text>`;
            }
            
            // X축 그리드 라인
            const timeLabels = chartData.labels;
            if (timeLabels && timeLabels.length > 0) {
                for (let i = 0; i < timeLabels.length; i += Math.max(1, Math.floor(timeLabels.length / 6))) {
                    const x = 50 + (i * (width - 100) / (timeLabels.length - 1));
                    const timeLabel = timeLabels[i];
                    
                    svg += `<line x1="${x}" y1="60" x2="${x}" y2="${height - 80}" stroke="#e9ecef" stroke-width="1"/>`;
                    
                    if (timeLabel instanceof Date) {
                        const timeStr = timeLabel.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
                        svg += `<text x="${x}" y="${height - 60}" font-family="Arial, sans-serif" font-size="10" fill="#6c757d" text-anchor="middle">${timeStr}</text>`;
                    }
                }
            }
            
            // 축 라인
            svg += `<line x1="50" y1="60" x2="50" y2="${height - 80}" stroke="#212529" stroke-width="2"/>`; // Y축
            svg += `<line x1="50" y1="${height - 80}" x2="${width - 50}" y2="${height - 80}" stroke="#212529" stroke-width="2"/>`; // X축
            
            svg += `</svg>`;
            
            return svg;
        }

        // SVG 파일 다운로드
        function downloadSVG(svgData, filename) {
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
        }

        // 모달 페이지를 SVG로 내보내기 (피그마 편집용)
        function exportModalAsSVG(chartId) {
            const config = chartConfigs[chartId];
            if (!config) return;
            
            try {
                // 모달의 실제 DOM 요소 가져오기
                const modal = document.getElementById('chartSettingsModal');
                const modalContent = document.querySelector('.settings-modal-content');
                
                if (!modal || !modalContent) {
                    showNotification('모달을 찾을 수 없습니다.');
                    return;
                }
                
                // 모달의 스타일 정보 수집
                const computedStyle = window.getComputedStyle(modalContent);
                const rect = modalContent.getBoundingClientRect();
                
                // SVG 생성
                const svgData = createModalSVG(modalContent, config, rect);
                
                // SVG 파일 다운로드
                downloadSVG(svgData, `${config.name}_Modal_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.svg`);
                
                showNotification(`${config.name} 모달이 SVG 파일로 저장되었습니다. (피그마 편집 가능)`);
            } catch (error) {
                console.error('모달 SVG 내보내기 오류:', error);
                showNotification('모달 SVG 내보내기 중 오류가 발생했습니다.');
            }
        }

        // 모달 SVG 생성
        function createModalSVG(modalElement, config, rect) {
            const width = 600; // 고정 너비
            const height = 800; // 고정 높이
            const padding = 24;
            const sectionSpacing = 24;
            
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
            
            // 배경
            svg += `<rect width="100%" height="100%" fill="#ffffff" stroke="#e9ecef" stroke-width="1" rx="8"/>`;
            
            // 헤더
            svg += `<rect x="0" y="0" width="${width}" height="60" fill="#f8f9fa" rx="8"/>`;
            svg += `<text x="${padding}" y="35" font-family="Inter, Arial, sans-serif" font-size="18" font-weight="600" fill="#212529">${config.name} 설정</text>`;
            svg += `<circle cx="${width - 30}" cy="30" r="12" fill="#f1f5f9" stroke="#e9ecef"/>`;
            svg += `<text x="${width - 30}" y="35" font-family="Arial, sans-serif" font-size="16" fill="#6c757d" text-anchor="middle">×</text>`;
            
            let currentY = 80;
            
            // 1. 차트 종류 설정 섹션
            svg += createSettingsSection(svg, padding, currentY, width - padding * 2, 100, 
                "차트 종류 설정", "fas fa-chart-line", [
                    { label: "차트 타입:", value: "라인 차트", type: "select" }
                ]);
            currentY += 100 + sectionSpacing;
            
            // 2. 시간 범위 설정 섹션
            svg += createSettingsSection(svg, padding, currentY, width - padding * 2, 100,
                "시간 범위 설정", "fas fa-clock", [
                    { label: "조회 범위:", value: "글로벌 설정 사용", type: "select" }
                ]);
            currentY += 100 + sectionSpacing;
            
            // 3. X축 범위 설정 섹션
            svg += createSettingsSection(svg, padding, currentY, width - padding * 2, 120,
                "X축 범위 설정", "fas fa-expand-arrows-alt", [
                    { label: "X축 최소값:", value: "자동", type: "input" },
                    { label: "X축 최대값:", value: "자동", type: "input" }
                ]);
            currentY += 120 + sectionSpacing;
            
            // 4. 임계치 설정 섹션
            svg += createSettingsSection(svg, padding, currentY, width - padding * 2, 120,
                "임계치 설정", "fas fa-sliders-h", [
                    { label: "경고 임계치:", value: `${Math.round(config.max * 0.7)}`, type: "input", unit: config.unit },
                    { label: "위험 임계치:", value: `${Math.round(config.max * 0.9)}`, type: "input", unit: config.unit }
                ]);
            currentY += 120 + sectionSpacing;
            
            // 5. 버튼 영역
            const buttonY = height - 80;
            svg += `<rect x="${width - 200}" y="${buttonY}" width="80" height="36" fill="#f1f5f9" stroke="#e9ecef" rx="4"/>`;
            svg += `<text x="${width - 160}" y="${buttonY + 22}" font-family="Inter, Arial, sans-serif" font-size="14" fill="#495057" text-anchor="middle">취소</text>`;
            
            svg += `<rect x="${width - 110}" y="${buttonY}" width="80" height="36" fill="#3b82f6" rx="4"/>`;
            svg += `<text x="${width - 70}" y="${buttonY + 22}" font-family="Inter, Arial, sans-serif" font-size="14" fill="white" text-anchor="middle">적용</text>`;
            
            svg += `</svg>`;
            
            return svg;
        }

        // 설정 섹션 SVG 생성
        function createSettingsSection(svg, x, y, width, height, title, icon, items) {
            let sectionSvg = '';
            
            // 섹션 배경
            sectionSvg += `<rect x="${x}" y="${y}" width="${width}" height="${height}" fill="#f8f9fa" stroke="#e9ecef" rx="6"/>`;
            
            // 섹션 제목
            sectionSvg += `<text x="${x + 16}" y="${y + 25}" font-family="Inter, Arial, sans-serif" font-size="14" font-weight="600" fill="#212529">${title}</text>`;
            
            // 아이템들
            items.forEach((item, index) => {
                const itemY = y + 45 + (index * 35);
                
                // 라벨
                sectionSvg += `<text x="${x + 16}" y="${itemY}" font-family="Inter, Arial, sans-serif" font-size="12" fill="#495057">${item.label}</text>`;
                
                if (item.type === 'select') {
                    // 셀렉트 박스
                    sectionSvg += `<rect x="${x + width - 140}" y="${itemY - 15}" width="120" height="24" fill="white" stroke="#e9ecef" rx="4"/>`;
                    sectionSvg += `<text x="${x + width - 80}" y="${itemY - 2}" font-family="Inter, Arial, sans-serif" font-size="12" fill="#495057" text-anchor="middle">${item.value}</text>`;
                    sectionSvg += `<polygon points="${x + width - 20},${itemY - 8} ${x + width - 15},${itemY - 3} ${x + width - 10},${itemY - 8}" fill="#6c757d"/>`;
                } else if (item.type === 'input') {
                    // 입력 필드
                    sectionSvg += `<rect x="${x + width - 140}" y="${itemY - 15}" width="120" height="24" fill="white" stroke="#e9ecef" rx="4"/>`;
                    sectionSvg += `<text x="${x + width - 80}" y="${itemY - 2}" font-family="Inter, Arial, sans-serif" font-size="12" fill="#6c757d" text-anchor="middle">${item.value}</text>`;
                    
                    if (item.unit) {
                        sectionSvg += `<text x="${x + width - 10}" y="${itemY}" font-family="Inter, Arial, sans-serif" font-size="10" fill="#6c757d">${item.unit}</text>`;
                    }
                }
            });
            
            return sectionSvg;
        }

        // 드래그 앤 드롭 활성화
        function enableDragAndDrop() {
            console.log('🔧 드래그 앤 드롭 활성화 시작');
            
            const cards = document.querySelectorAll('.chart-card');
            const grid = document.getElementById('chartsGrid');
            
            console.log('📊 찾은 카드 수:', cards.length);
            console.log('📋 그리드 요소:', grid);
            console.log('🎯 현재 모드:', currentMode);
            
            if (cards.length === 0) {
                console.log('❌ 차트카드가 없습니다. 잠시 후 다시 시도합니다.');
                setTimeout(() => enableDragAndDrop(), 500);
                return;
            }
            
            // 기존 드래그 핸들 모두 제거
            document.querySelectorAll('.drag-handle').forEach(handle => handle.remove());
            
            // 드래그 앤 드롭 설정
            cards.forEach((card, index) => {
                console.log(`🎨 카드 ${index} (${card.id}) 드래그 설정 시작`);
                card.style.cursor = 'move';
                card.style.userSelect = 'none';
                
                // 드래그 핸들 제거 (카드 전체 드래그로 대체)
                const existingHandle = card.querySelector('.drag-handle');
                if (existingHandle) {
                    existingHandle.remove();
                }
                console.log(`✅ 드래그 핸들 제거 완료: ${card.id}`);
                
                // 카드 전체에 드래그 이벤트 추가 (버튼 제외)
                card.addEventListener('mousedown', function(e) {
                    // 버튼이나 입력 요소를 클릭한 경우 드래그하지 않음
                    if (e.target.tagName === 'BUTTON' || 
                        e.target.tagName === 'INPUT' || 
                        e.target.tagName === 'SELECT' ||
                        e.target.closest('button') ||
                        e.target.closest('input') ||
                        e.target.closest('select')) {
                        return;
                    }
                    
                    console.log('🖱️ 카드 드래그 시작:', card.id);
                    console.log('📍 마우스 위치:', e.clientX, e.clientY);
                    
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const startRect = card.getBoundingClientRect();
                    
                    // 카드 선택 효과
                    card.classList.add('selected');
                    
                    card.style.position = 'fixed';
                    card.style.zIndex = '1000';
                    card.style.pointerEvents = 'none';
                    card.style.transform = 'rotate(2deg) scale(1.05)';
                    card.style.opacity = '0.9';
                    card.style.left = startRect.left + 'px';
                    card.style.top = startRect.top + 'px';
                    card.style.width = startRect.width + 'px';
                    card.style.height = startRect.height + 'px';
                    card.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.3)';
                    card.classList.add('dragging');
                    
                    function handleMouseMove(e) {
                        card.style.left = (startRect.left + e.clientX - startX) + 'px';
                        card.style.top = (startRect.top + e.clientY - startY) + 'px';
                    }
                    
                    function handleMouseUp(e) {
                        console.log('드롭:', e.target);
                        
                        const targetCard = e.target.closest('.chart-card');
                        if (targetCard && targetCard !== card) {
                            const grid = document.getElementById('chartsGrid');
                            const allCards = Array.from(grid.children);
                            const draggedIndex = allCards.indexOf(card);
                            const targetIndex = allCards.indexOf(targetCard);
                            
                            console.log('드래그 인덱스:', draggedIndex, '타겟 인덱스:', targetIndex);
                            
                            if (draggedIndex < targetIndex) {
                                grid.insertBefore(card, targetCard.nextSibling);
                            } else {
                                grid.insertBefore(card, targetCard);
                            }
                            
                            showNotification('차트 순서가 변경되었습니다.');
                            console.log('차트 순서 변경 완료');
                        }
                        
                        // 스타일 복원
                        card.style.position = '';
                        card.style.zIndex = '';
                        card.style.pointerEvents = '';
                        card.style.transform = '';
                        card.style.opacity = '';
                        card.style.left = '';
                        card.style.top = '';
                        card.style.width = '';
                        card.style.height = '';
                        card.style.boxShadow = '';
                        card.classList.remove('dragging');
                        card.classList.remove('selected');
                        
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    }
                    
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    
                    e.preventDefault();
                    e.stopPropagation();
                });
            });
            
            console.log('드래그 앤 드롭 활성화 완료');
        }

        // 드래그 앤 드롭 비활성화
        function disableDragAndDrop() {
            const cards = document.querySelectorAll('.chart-card');
            
            cards.forEach(card => {
                card.style.cursor = 'default';
                card.style.userSelect = 'auto';
                card.style.position = '';
                card.style.zIndex = '';
                card.style.pointerEvents = '';
                card.style.transform = '';
                card.style.opacity = '';
                card.style.left = '';
                card.style.top = '';
                
                // 드래그 핸들 제거
                const dragHandle = card.querySelector('.drag-handle');
                if (dragHandle) {
                    dragHandle.remove();
                }
            });
        }


        // 드래그 이벤트 핸들러
        let draggedElement = null;

        // 리사이즈 관련 변수
        let isResizing = false;
        let resizeElement = null;
        let resizeDirection = null;
        let startX = 0;
        let startY = 0;
        let startWidth = 0;
        let startHeight = 0;

        function handleDragStart(e) {
            console.log('드래그 시작 이벤트:', e.target);
            
            // 리사이즈 핸들에서 드래그가 시작된 경우 무시
            if (e.target.classList.contains('resize-handle')) {
                console.log('리사이즈 핸들에서 드래그 시작 - 무시');
                e.preventDefault();
                return false;
            }
            
            // 차트 카드에서만 드래그 허용
            const chartCard = e.target.closest('.chart-card');
            console.log('찾은 차트 카드:', chartCard);
            
            if (chartCard) {
                draggedElement = chartCard;
                draggedElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', draggedElement.outerHTML);
                console.log('드래그 시작 성공:', draggedElement.id);
            } else {
                console.log('차트 카드를 찾을 수 없음');
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            console.log('드롭 이벤트:', e.target);
            console.log('드래그된 요소:', draggedElement);
            
            const targetCard = e.target.closest('.chart-card');
            console.log('타겟 카드:', targetCard);
            
            if (targetCard && targetCard !== draggedElement && draggedElement) {
                const grid = document.getElementById('chartsGrid');
                const allCards = Array.from(grid.children);
                const draggedIndex = allCards.indexOf(draggedElement);
                const targetIndex = allCards.indexOf(targetCard);

                console.log('드래그된 인덱스:', draggedIndex, '타겟 인덱스:', targetIndex);

                if (draggedIndex < targetIndex) {
                    grid.insertBefore(draggedElement, targetCard.nextSibling);
                    console.log('뒤로 이동');
                } else {
                    grid.insertBefore(draggedElement, targetCard);
                    console.log('앞으로 이동');
                }
                
                showNotification('차트 순서가 변경되었습니다.');
                console.log('차트 순서 변경 완료');
            } else {
                console.log('드롭 조건 불만족:', {
                    targetCard: !!targetCard,
                    isDifferent: targetCard !== draggedElement,
                    hasDraggedElement: !!draggedElement
                });
            }
        }

        function handleDragEnd(e) {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
            draggedElement = null;
            }
        }


        // 알림 표시
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            const bgColor = type === 'error' ? '#ef4444' : '#10b981';
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${bgColor};
                color: white;
                padding: 0.75rem 1rem;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 10000;
                font-weight: 500;
                font-size: 0.8rem;
                transition: all 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => notification.remove(), 300);
            }, 2500);
        }

        // 현재 시간 업데이트
        function updateCurrentTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('ko-KR');
            document.getElementById('currentTime').textContent = timeString;
        }

        // 모달 외부 클릭 시 닫기
        document.addEventListener('click', function(e) {
            if (e.target.id === 'detailModal') {
                closeDetailModal();
            }
            
            if (e.target.id === 'chartSettingsModal') {
                closeChartSettings();
            }
            
            if (e.target.id === 'serverSettingsModal') {
                closeServerSettings();
            }
            
            if (e.target.id === 'dashboardManagementModal') {
                closeDashboardManagement();
            }
            
            if (e.target.id === 'deleteConfirmModal') {
                closeDeleteConfirm();
            }
            
            if (e.target.id === 'createDashboardModal') {
                closeCreateDashboard();
            }
            
            const thresholdPanel = document.getElementById('thresholdPanel');
            if (!thresholdPanel.contains(e.target) && !e.target.closest('.chart-action-btn')) {
                closeThresholdPanel();
            }
        });

        // 키보드 이벤트
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeDetailModal();
                closeChartSettings();
                closeServerSettings();
                closeDashboardManagement();
                closeThresholdPanel();
                closeDeleteConfirm();
                closeCreateDashboard();
            }
        });

        // 조회 기능 관련 변수
        let isRealtimeMode = true;
        let realtimeInterval = null;

        // 실시간 모드 시작
        function startRealtime() {
            isRealtimeMode = true;
            document.getElementById('realtimeMode').style.display = 'flex';
            document.getElementById('queryMode').style.display = 'none';
            startRealtimeUpdate();
        }

        // 실시간 모드 중지
        function stopRealtime() {
            isRealtimeMode = false;
            document.getElementById('realtimeMode').style.display = 'none';
            document.getElementById('queryMode').style.display = 'flex';
            stopRealtimeUpdate();
            setupDateTimeInputs();
        }

        // 실시간 업데이트 시작
        function startRealtimeUpdate() {
            if (realtimeInterval) {
                clearInterval(realtimeInterval);
            }
            realtimeInterval = setInterval(() => {
                updateChartsForRealtime();
            }, 300000); // 5분마다 업데이트
        }

        // 실시간 업데이트 중지
        function stopRealtimeUpdate() {
            if (realtimeInterval) {
                clearInterval(realtimeInterval);
                realtimeInterval = null;
            }
        }

        // 실시간 차트 업데이트
        function updateChartsForRealtime() {
            console.log('실시간 차트 업데이트');
            // 실제 구현에서는 서버에서 최신 데이터를 가져와서 차트를 업데이트
        }

        // 날짜/시간 입력 설정
        function setupDateTimeInputs() {
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            document.getElementById('startDateTime').value = formatDateTimeLocal(oneHourAgo);
            document.getElementById('endDateTime').value = formatDateTimeLocal(now);
            
            updateDurationBadge();
            setupDateTimeListeners();
        }

        // 날짜/시간 포맷팅
        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // 기간 배지 업데이트
        function updateDurationBadge() {
            const startTime = new Date(document.getElementById('startDateTime').value);
            const endTime = new Date(document.getElementById('endDateTime').value);
            const duration = endTime - startTime;
            
            let durationText = '';
            if (duration < 60 * 60 * 1000) {
                durationText = Math.round(duration / (60 * 1000)) + '분';
            } else if (duration < 24 * 60 * 60 * 1000) {
                durationText = Math.round(duration / (60 * 60 * 1000)) + '시간';
            } else {
                durationText = Math.round(duration / (24 * 60 * 60 * 1000)) + '일';
            }
            
            document.getElementById('durationBadge').textContent = durationText;
        }

        // 날짜/시간 입력 리스너 설정
        function setupDateTimeListeners() {
            document.getElementById('startDateTime').addEventListener('change', updateDurationBadge);
            document.getElementById('endDateTime').addEventListener('change', updateDurationBadge);
        }

        // 기간 변경 함수
        function changeDuration(value) {
            console.log('조회 기간 변경:', value);
            
            const startDateTime = document.getElementById('startDateTime');
            const endDateTime = document.getElementById('endDateTime');
            const now = new Date();
            
            switch(value) {
                case '5m':
                    setTimeRange(now, 5 * 60 * 1000);
                    break;
                case '10m':
                    setTimeRange(now, 10 * 60 * 1000);
                    break;
                case '1h':
                    setTimeRange(now, 60 * 60 * 1000);
                    break;
                case '3h':
                    setTimeRange(now, 3 * 60 * 60 * 1000);
                    break;
                case '1d':
                    setTimeRange(now, 24 * 60 * 60 * 1000);
                    break;
                case '7d':
                    setTimeRange(now, 7 * 24 * 60 * 60 * 1000);
                    break;
                case '30d':
                    setTimeRange(now, 30 * 24 * 60 * 60 * 1000);
                    break;
                case 'today':
                    setTodayRange();
                    break;
                case 'yesterday':
                    setYesterdayRange();
                    break;
                case 'start-5m':
                    setStartTimeRange(5 * 60 * 1000);
                    break;
                case 'start-10m':
                    setStartTimeRange(10 * 60 * 1000);
                    break;
                case 'start-1h':
                    setStartTimeRange(60 * 60 * 1000);
                    break;
            }
        }

        // 시간 범위 설정
        function setTimeRange(endTime, duration) {
            const startTime = new Date(endTime.getTime() - duration);
            document.getElementById('startDateTime').value = formatDateTimeLocal(startTime);
            document.getElementById('endDateTime').value = formatDateTimeLocal(endTime);
        }

        // 오늘 범위 설정
        function setTodayRange() {
            const today = new Date();
            const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0);
            const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59);
            document.getElementById('startDateTime').value = formatDateTimeLocal(startOfDay);
            document.getElementById('endDateTime').value = formatDateTimeLocal(endOfDay);
        }

        // 어제 범위 설정
        function setYesterdayRange() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const startOfDay = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 0, 0, 0);
            const endOfDay = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);
            document.getElementById('startDateTime').value = formatDateTimeLocal(startOfDay);
            document.getElementById('endDateTime').value = formatDateTimeLocal(endOfDay);
        }

        // 시작시간 기준 범위 설정
        function setStartTimeRange(duration) {
            const startTime = new Date();
            const endTime = new Date(startTime.getTime() + duration);
            document.getElementById('startDateTime').value = formatDateTimeLocal(startTime);
            document.getElementById('endDateTime').value = formatDateTimeLocal(endTime);
        }

        // 날짜시간 로컬 포맷
        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // 간격 설정 리스너
        function setupIntervalListener() {
            const interval = document.getElementById('timeInterval').value;
            console.log('시간 간격 설정:', interval);
        }

        // 날짜 선택기 열기
        function openDatePicker() {
            document.getElementById('startDateTime').showPicker();
        }

        // 조회 실행
        function executeQuery() {
            const startTime = document.getElementById('startDateTime').value;
            const endTime = document.getElementById('endDateTime').value;
            const interval = document.getElementById('timeInterval').value;
            
            console.log('조회 실행:', { startTime, endTime, interval });
            updateChartsForQuery(startTime, endTime, interval);
            showNotification('조회가 실행되었습니다.');
        }

        // 조회용 차트 업데이트
        function updateChartsForQuery(startTime, endTime, interval) {
            console.log('조회용 차트 업데이트:', { startTime, endTime, interval });
            // 실제 구현에서는 서버에서 지정된 기간의 데이터를 가져와서 차트를 업데이트
        }

        // JSON 내보내기
        function downloadDashboardJson() {
            try {
                const dashboardData = {
                    metadata: {
                        title: "AMP 모니터링 대시보드",
                        version: "1.0",
                        exportDate: new Date().toISOString(),
                        mode: currentMode
                    },
                    settings: {
                        globalTimeRange: document.getElementById('globalTimeRange').value,
                        xAxisRangeMode: document.getElementById('xAxisRangeMode').value,
                        dataMode: document.getElementById('dataMode').value
                    },
                    charts: Object.keys(charts).map(chartId => ({
                        id: chartId,
                        type: charts[chartId].config.type,
                        visible: document.getElementById(`card-${chartId}`).style.display !== 'none'
                    })),
                    layout: {
                        chartOrder: Array.from(document.getElementById('chartsGrid').children).map(card => card.id),
                        cardSizes: Array.from(document.querySelectorAll('.chart-card')).map(card => ({
                            id: card.id,
                            width: card.style.width || 'auto',
                            height: card.style.height || 'auto'
                        }))
                    }
                };

                const dataStr = JSON.stringify(dashboardData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `amp-dashboard-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showNotification('대시보드가 JSON 파일로 내보내기되었습니다.');
            } catch (error) {
                console.error('JSON 내보내기 오류:', error);
                showNotification('내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        // JSON 업로드
        function uploadDashboardJson() {
            document.getElementById('jsonFileInput').click();
        }

        // JSON 파일 처리
        function handleJsonFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const dashboardData = JSON.parse(e.target.result);
                    restoreDashboardFromJson(dashboardData);
                    showNotification('대시보드가 성공적으로 가져오기되었습니다.');
                } catch (error) {
                    console.error('JSON 파싱 오류:', error);
                    showNotification('대시보드 가져오기 중 오류가 발생했습니다.', 'error');
                }
            };
            reader.readAsText(file);
        }

        // JSON에서 대시보드 복원
        function restoreDashboardFromJson(dashboardData) {
            try {
                // 설정 복원
                if (dashboardData.settings) {
                    if (dashboardData.settings.globalTimeRange) {
                        document.getElementById('globalTimeRange').value = dashboardData.settings.globalTimeRange;
                    }
                    if (dashboardData.settings.xAxisRangeMode) {
                        document.getElementById('xAxisRangeMode').value = dashboardData.settings.xAxisRangeMode;
                    }
                    if (dashboardData.settings.dataMode) {
                        document.getElementById('dataMode').value = dashboardData.settings.dataMode;
                    }
                }

                // 모드 복원
                if (dashboardData.metadata && dashboardData.metadata.mode) {
                    switchMode(dashboardData.metadata.mode);
                }

                // 차트 순서 복원
                if (dashboardData.layout && dashboardData.layout.chartOrder) {
                    restoreChartOrder(dashboardData.layout.chartOrder);
                }

                // 카드 크기 복원
                if (dashboardData.layout && dashboardData.layout.cardSizes) {
                    restoreCardSizes(dashboardData.layout.cardSizes);
                }

                // 차트 가시성 복원
                if (dashboardData.charts) {
                    dashboardData.charts.forEach(chart => {
                        const card = document.getElementById(`card-${chart.id}`);
                        if (card) {
                            card.style.display = chart.visible ? 'block' : 'none';
                        }
                    });
                }

            } catch (error) {
                console.error('대시보드 복원 오류:', error);
                throw error;
            }
        }

        // 차트 순서 복원
        function restoreChartOrder(chartOrder) {
            const grid = document.getElementById('chartsGrid');
            chartOrder.forEach(cardId => {
                const card = document.getElementById(cardId);
                if (card) {
                    grid.appendChild(card);
                }
            });
        }

        // 카드 크기 복원
        function restoreCardSizes(cardSizes) {
            cardSizes.forEach(cardSize => {
                const card = document.getElementById(cardSize.id);
                if (card) {
                    if (cardSize.width !== 'auto') {
                        card.style.width = cardSize.width;
                    }
                    if (cardSize.height !== 'auto') {
                        card.style.height = cardSize.height;
                    }
                }
            });
        }


        // 내보내기 모달 닫기
        function closeExportModal() {
            const exportModal = document.getElementById('exportModal');
            exportModal.style.display = 'none';
            exportModal.classList.remove('show');
            console.log('내보내기 모달 닫기 완료');
        }

        // 가져오기 모달 닫기
        function closeImportModal() {
            const importModal = document.getElementById('importModal');
            importModal.style.display = 'none';
            importModal.classList.remove('show');
            console.log('가져오기 모달 닫기 완료');
        }

        // 파일 입력 트리거
        function triggerFileInput() {
            document.getElementById('importFileInput').click();
        }

        // 파일 선택 처리
        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.toLowerCase().endsWith('.json')) {
                showNotification('JSON 파일만 업로드할 수 있습니다.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    importFileData = data;
                    showImportPreview(data);
                    document.getElementById('importExecuteBtn').disabled = false;
                } catch (error) {
                    showNotification('유효하지 않은 JSON 파일입니다.', 'error');
                    console.error('JSON 파싱 오류:', error);
                }
            };
            reader.readAsText(file);
        }

        // 가져오기 미리보기 표시
        function showImportPreview(data) {
            const preview = document.getElementById('importPreview');
            const content = document.getElementById('previewContent');
            
            let previewHtml = '<div class="preview-item">';
            previewHtml += `<strong>대시보드명:</strong> ${data.metadata?.title || '알 수 없음'}<br>`;
            previewHtml += `<strong>버전:</strong> ${data.metadata?.version || '1.0'}<br>`;
            previewHtml += `<strong>내보내기 일시:</strong> ${data.metadata?.exportDate || '알 수 없음'}<br>`;
            previewHtml += `<strong>차트 수:</strong> ${data.charts?.length || 0}개<br>`;
            previewHtml += `<strong>설정 포함:</strong> ${data.settings ? '예' : '아니오'}<br>`;
            previewHtml += `<strong>레이아웃 포함:</strong> ${data.layout ? '예' : '아니오'}`;
            previewHtml += '</div>';
            
            content.innerHTML = previewHtml;
            preview.style.display = 'block';
        }

        // 내보내기 실행
        function executeExport() {
            try {
                const includeSettings = document.getElementById('includeSettings').checked;
                const includeLayout = document.getElementById('includeLayout').checked;
                const includeData = document.getElementById('includeData').checked;
                
                const dashboardData = {
                    metadata: {
                        title: "AMP 모니터링 대시보드",
                        version: "1.0",
                        exportDate: new Date().toISOString(),
                        mode: currentMode
                    }
                };

                if (includeSettings) {
                    dashboardData.settings = {
                        globalTimeRange: document.getElementById('globalTimeRange').value,
                        xAxisRangeMode: document.getElementById('xAxisRangeMode').value,
                        dataMode: document.getElementById('dataMode').value
                    };
                }

                if (includeLayout) {
                    dashboardData.layout = {
                        chartOrder: Array.from(document.getElementById('chartsGrid').children).map(card => card.id),
                        cardSizes: Array.from(document.querySelectorAll('.chart-card')).map(card => ({
                            id: card.id,
                            width: card.style.width || 'auto',
                            height: card.style.height || 'auto'
                        }))
                    };
                }

                dashboardData.charts = Object.keys(charts).map(chartId => ({
                    id: chartId,
                    type: charts[chartId].config.type,
                    visible: document.getElementById(`card-${chartId}`).style.display !== 'none',
                    data: includeData ? charts[chartId].data : null
                }));

                const dataStr = JSON.stringify(dashboardData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `amp-dashboard-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showNotification('대시보드가 성공적으로 내보내기되었습니다.');
                closeExportModal();
            } catch (error) {
                console.error('내보내기 오류:', error);
                showNotification('내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        // 가져오기 실행
        function executeImport() {
            if (!importFileData) {
                showNotification('파일을 먼저 선택해주세요.', 'error');
                return;
            }

            // 가져오기 대상 확인
            const destination = document.querySelector('input[name="importDestination"]:checked');
            const targetType = destination ? destination.value : 'admin';
            
            console.log('가져오기 대상:', targetType);

            try {
                // 설정 복원
                if (importFileData.settings) {
                    if (importFileData.settings.globalTimeRange) {
                        document.getElementById('globalTimeRange').value = importFileData.settings.globalTimeRange;
                    }
                    if (importFileData.settings.xAxisRangeMode) {
                        document.getElementById('xAxisRangeMode').value = importFileData.settings.xAxisRangeMode;
                    }
                    if (importFileData.settings.dataMode) {
                        document.getElementById('dataMode').value = importFileData.settings.dataMode;
                    }
                }

                // 레이아웃 복원
                if (importFileData.layout) {
                    if (importFileData.layout.chartOrder) {
                        restoreChartOrder(importFileData.layout.chartOrder);
                    }
                    if (importFileData.layout.cardSizes) {
                        restoreCardSizes(importFileData.layout.cardSizes);
                    }
                }

                // 차트 가시성 복원
                if (importFileData.charts) {
                    importFileData.charts.forEach(chart => {
                        const card = document.getElementById(`card-${chart.id}`);
                        if (card) {
                            card.style.display = chart.visible ? 'block' : 'none';
                        }
                    });
                }

                showNotification('대시보드가 성공적으로 가져오기되었습니다.');
                closeImportModal();
            } catch (error) {
                console.error('가져오기 오류:', error);
                showNotification('가져오기 중 오류가 발생했습니다.', 'error');
            }
        }

        // 모드 전환 시 뷰모드 액션 버튼 표시/숨김
        function updateViewModeActions() {
            const viewModeActions = document.getElementById('viewModeActions');
            if (viewModeActions) {
                if (currentMode === 'view') {
                    viewModeActions.classList.remove('hidden');
                } else {
                    viewModeActions.classList.add('hidden');
                }
            }
        }

        // setViewMode 함수 수정
        function setViewMode() {
            currentMode = 'view';
            document.getElementById('viewModeBtn').classList.add('active');
            document.getElementById('editModeBtn').classList.remove('active');
            
            // 카드 옵션 패널 숨기기
            document.getElementById('cardOptionsPanel').style.display = 'none';
            
            // 엔진 목록 버튼 숨기기 (수정모드에서만 표시)
            document.getElementById('engineListToggle').style.display = 'none';
            
            // 리사이즈 핸들 제거
            document.querySelectorAll('.resize-handles').forEach(handle => handle.remove());
            
            // 드래그 앤 드롭 비활성화
            disableDragAndDrop();
            
            // 뷰모드 액션 버튼 표시
            updateViewModeActions();
        }

        // setEditMode 함수 수정
        function setEditMode() {
            console.log('수정모드 시작');
            currentMode = 'edit';
            document.getElementById('editModeBtn').classList.add('active');
            document.getElementById('viewModeBtn').classList.remove('active');
            
            // 카드 옵션 패널 표시
            document.getElementById('cardOptionsPanel').style.display = 'block';
            
            // 엔진 목록 버튼 표시 (수정모드에서만 표시)
            document.getElementById('engineListToggle').style.display = 'flex';
            
            // 리사이즈 핸들 추가
            setupResizeListeners();
            
            // 드래그 앤 드롭 활성화 (지연 실행)
            setTimeout(() => {
                console.log('⏰ 드래그 앤 드롭 활성화 시도 (100ms 후)');
                enableDragAndDrop();
            }, 100);
            
            // 뷰모드 액션 버튼 숨기기
            updateViewModeActions();
        }

        // 모달 외부 클릭 시 닫기
        document.addEventListener('click', function(e) {
            if (e.target.id === 'exportModal') {
                closeExportModal();
            }
            if (e.target.id === 'importModal') {
                closeImportModal();
            }
        });

        // 드래그 앤 드롭 이벤트 (가져오기 모달)
        const uploadArea = document.getElementById('importUploadArea');
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.name.toLowerCase().endsWith('.json')) {
                    const input = document.getElementById('importFileInput');
                    input.files = files;
                    handleImportFile({ target: { files: files } });
                } else {
                    showNotification('JSON 파일만 업로드할 수 있습니다.', 'error');
                }
            }
        });

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', function() {
            initializeDashboard();
            // 초기 모드에 따라 버튼 표시/숨김
            setTimeout(() => {
                updateViewModeActions();
            }, 500);
            
            // 모든 모달 초기화 (닫힌 상태로 설정)
            initializeModals();
            
            // 대시보드 선택박스 초기화
            setTimeout(() => {
                updateDashboardSelector();
            }, 1000);
            
            // 드롭박스 초기화
            initializeDurationDropdown();
        });

        // 드롭박스 초기화
        function initializeDurationDropdown() {
            const dropdown = document.getElementById('durationBadge');
            if (dropdown) {
                // 기본값 설정
                dropdown.value = '1h';
                console.log('✅ 드롭박스 초기화 완료:', dropdown.value);
            }
        }

        // 새로고침 간격 변경 함수
        function changeRefreshInterval(value) {
            console.log('새로고침 간격 변경:', value);
            
            // 실제 구현에서는 여기서 새로고침 간격을 설정
            switch(value) {
                case '5m':
                    console.log('5분 간격으로 설정');
                    break;
                case '10m':
                    console.log('10분 간격으로 설정');
                    break;
                case '1h':
                    console.log('1시간 간격으로 설정');
                    break;
            }
        }

        // 모든 모달 초기화
        function initializeModals() {
            console.log('🔄 모든 모달 초기화');
            
            // 대시보드 관리 모달
            const dashboardModal = document.getElementById('dashboardManagementModal');
            if (dashboardModal) {
                dashboardModal.style.display = 'none';
            }
            
            // 대시보드 수정 모달
            const editModal = document.getElementById('editDashboardModal');
            if (editModal) {
                editModal.style.display = 'none';
            }
            
            console.log('✅ 모든 모달 초기화 완료');
        }

        // 추가 초기화 (더 확실하게)
        window.addEventListener('load', function() {
            setTimeout(() => {
                updateViewModeActions();
            }, 1000);
        });
    </script>

    <!-- 기간조회 모달 -->
    <div id="periodQueryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>기간 조회 설정</h3>
                <button class="close-btn" onclick="closePeriodQueryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- 전체 설정을 따름 체크박스 -->
                <div class="global-settings-section">
                    <label class="global-checkbox-label">
                        <input type="checkbox" id="followGlobalSettings" onchange="toggleIndividualPeriod()">
                        <span class="global-checkmark"></span>
                        전체 설정을 따름
                    </label>
                </div>
                
                <!-- 개별 설정 영역 -->
                <div id="individualPeriodSettings" class="individual-period-settings">
                    <div class="query-panel">
                        <div class="realtime-mode" id="modalRealtimeMode" style="display: none;">
                            <button class="query-btn stop-btn" onclick="stopRealtime()" title="실시간 모니터링 중지">
                                <i class="fas fa-stop"></i>
                                정지
                            </button>
                            <div class="realtime-status">
                                <div class="status-indicator">
                                    <div class="pulse-circle"></div>
                                </div>
                                <span>실시간 감시중</span>
                            </div>
                            <select class="refresh-interval" id="modalRefreshInterval" onchange="changeRefreshInterval(this.value)">
                                <option value="5m" selected>실시간 5분</option>
                                <option value="10m">실시간 10분</option>
                                <option value="1h">실시간 1시간</option>
                            </select>
                        </div>
                        
                        <div class="query-mode" id="modalQueryMode">
                            <button class="query-btn start-btn" onclick="startRealtime()" title="실시간 모니터링 시작">
                                <i class="fas fa-play"></i>
                                실시간
                            </button>
                            <div class="datetime-inputs">
                                <input type="datetime-local" class="datetime-input" id="modalStartDateTime">
                                <span class="range-separator">~</span>
                                <input type="datetime-local" class="datetime-input" id="modalEndDateTime">
                            </div>
                            <select class="duration-badge" id="modalDurationBadge" onchange="changeDuration(this.value)">
                                <option value="5m">최근 5분</option>
                                <option value="10m">최근 10분</option>
                                <option value="1h" selected>최근 1시간</option>
                                <option value="3h">최근 3시간</option>
                                <option value="6h">최근 6시간</option>
                                <option value="12h">최근 12시간</option>
                                <option value="1d">최근 1일</option>
                                <option value="3d">최근 3일</option>
                                <option value="7d">최근 7일</option>
                                <option value="30d">최근 30일</option>
                                <option value="custom">사용자 정의</option>
                            </select>
                            <span class="interval-label">간격</span>
                            <select class="interval-select" id="modalTimeInterval" onchange="setupIntervalListener()">
                                <option value="1m">1분</option>
                                <option value="5m">5분</option>
                                <option value="10m">10분</option>
                                <option value="30m">30분</option>
                                <option value="1h">1시간</option>
                            </select>
                            <button class="query-btn execute-btn" onclick="executeQuery()" title="조회 실행">
                                <i class="fas fa-search"></i>
                                조회
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closePeriodQueryModal()">취소</button>
                <button class="btn btn-primary" onclick="applyPeriodQuery()">적용</button>
            </div>
        </div>
    </div>
</body>
</html>
